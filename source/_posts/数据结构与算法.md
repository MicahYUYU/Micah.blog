title: 数据结构与算法
author: Micah
date: 2020-09-26 18:52:04
tags:

---

#### 课程介绍

- 继续刷分

#### 课程考核

#### content

##### Chapter 1 Data Structures and algrothm

###### 1.1 data structure 数据结构

1. data structure 数据结构  
   定义：一类数据的表示和其相关的操作  
   任何记录的组织（数据结构），都要能够进行**增删改查**的操作

2. Efficiency 效率  
   一个算法（solution）如果能在所要求的**资源限制（resource constraint）**内解决好，那么他就是**有效的（efficient）**。

3. 数据结构的选择

   - 分析问题。**找到解决方案（算法）必须满足的资源限制**
   - 决定所支持的基本操作（增删查等行为），衡量每种操作的资源限制
   - 选择最接近这些代价的数据结构

4. Philosophy  
   **没有任何一种数据结构在所有情况（situation）都比其他都优秀**：  
   每种数据结构都有它在时间和空间上的资源限制，只有在仔细分析问题的特征之后，我们才能知道最适合这个工作的是哪一种数据结构。

###### 1.2 ADT 抽象数据类型

1. ADT definition

   - ADT：一个**类型（type，一组值的集合）**，和定义在这个类型上的**操作（operation）**。
   - 每一种操作由他的**输入输出（input & output）**来定义。
   - 封装（encapsulation）：对外隐藏实现操作的细节。

   ![pic1](https://pic.downk.cc/item/5f7c11d6160a154a67e8b6c0.png)

2. Data Structure

   - **数据结构是 ADT 的物理实现**， ADT 的每种操作都会有一种或多种具体实现。
   - **数据结构**指的是在**内存**中数据的组织
   - **文件结构**指的是在**辅存**中数据的组织

3. Logical vs Physical Form 数据形式和物理形式  
   Data items have both a logical and a physical form  
   数据项同时具有**逻辑和物理**两种形式。

   - Logical form: definition of the data item within an ADT.  
     逻辑形式：利用 ADT 给出的数据项的定义。
   - Physical form: implementation of the data item within a data structure.  
     物理形式：数据结构中对数据项的实现。

   ![pic2](https://pic.downk.cc/item/5f7c1164160a154a67e89d08.png)

4. Vital features
   - 数据抽象: 用 ADT 描述程序处理的实体时，强调的是**其本质的特征、其所能完成的功能以及它和外部用户的接口**（即外界使用它的方法）。
   - 数据封装: 将实体的外部特性和其内部实现细节分离，并且**对外部用户隐藏其内部实现细节。**

###### 1.4 Problem、algrithm、program 问题、算法和程序

1. Problem 问题 ：**需要执行的任务**

   - 最好的想法是**对应一组输入，就有一组相应对输出**。
   - 问题定义应该包含**对任何可行方案所需对资源限制**。

2. Algorithm 算法：**解决一个问题的方法或过程**

   - 算法的任务就是把输入转换成输出
   - 一个问题有多种算法
   - 算法应该具有的性质：
     1. 正确性（correct）
     2. 具体步骤（concrete step）
     3. 确定性（no ambiguity 无二义性）
     4. 有限性（finite）
     5. 可终止性（terminate）

3. Program 程序  
   A computer program is an instance, or concrete representation, for an algorithm in some programming language.  
   一个计算机程序是**使用某种程序设计语言对一个算法对具体实现（或一种实例）**。

##### Chapter 2 Mathmatical Background

###### 2.4 级数求和

![pic3](https://pic.downk.cc/item/5f7c18a0160a154a67ea5f76.png)

###### 2.5 Recursion 递归

一个算法调用自己来完成它的部分工作，在解决某些问题时，一个算法需要调用自身。**如果一个算法直接调用自己或间接地调用自己，就称这个算法是递归的(Recursive)。**
根据调用方式的不同，它分为

- 直接递归(Direct Recursion)
- 间接递归(Indirect Recursion)

##### Chapter 3 Algorithm Analyse 算法分析

###### 3.1 Introduction

1. 增长率（growth rate）  
   当问题的规模（size）增大时，算法代价增长的速度。

2. 算法分析要包括两方面

   - 时间代价
   - 空间代价

3. Measure Efficientcy 效率的度量  
   处理一定**规模（size）**时，该算法所需要的**基本操作（basic operation）**的数目。  
   基本操作的条件：完成该操作所需时间与操作数的具体取值无关。

4. 增长率分类
   - linear growth rate / linear time cost 线性增长率（线性函数，cn）
   - quadratic growth rate （二次增长率 n^2）
   - exponential growth rate (指数增长率 2^n， n！)

###### 3.4 渐进分析

```
忽略系数
```

1. upper bound 上限  
   大 O 表示法：描述的是最大资源代价

2. lower bound 下限  
   大 omega 表示法：描述的是最小资源代价

##### Chapter 4 List、Stacks and Queue

###### 4.1 List(线性表)

1. 定义

   - 线性表是由元素（element）的数据项组成的一种**有序且有限**的序列
   - List elements have a position(位序)
   - 线性表有两种实现**_顺序表（sequential list）和链表（Linked list） _**

2. List ADT:

```cpp
template <class Elem> class List{
public:
    //清空线性表的内容
    virtual void clear()=0;
    //在当前位置插入一个元素
    virtual bool insert(const E& item)=0;
    //在线性表的最后插入一个元素
    virtual bool append(const E& item)=0;
    //在当前位置删除一个元素
    virtual E remove()=0;
    //把当前位置设置为线性表的开头
    virtual void moveToStart()=0;
    //把当前位置设置为线性表的最后
    virtual void moveToEnd()=0;
    //跳转到前一个元素
    virtual void prev()=0;
    //跳转到下一个元素
    virtual void next()=0;
    //返回线性表的长度
    virtual int Length() const =0;
    //返回当前元素的位置
	virtual int currPos() const = 0;
	//设置当前位置
	//Pos为你想设置的位置
	virtual void moveToPos (int Pos) = 0;
	//返回当前元素的值
	virtual const E& getValue() const = 0;
}
```

1. 顺序表（sequential List ｜ array based list）

   - 顺序表是基于数组来实现的,顺序表的私有成员如下

   ```cpp
   template<typename E>
   class AList:public List<E>{//表示AList是由List类继承来的
    private:
        int maxSize;//该顺序表能拥有的最大元素个数
        int listSize;//当前表中的元素个数
        int curr;//当前位置
        E* listArray;//支持顺序表的数组（核心）
   }
   ```

2. 链表（Linked List）

   - 定义：使用指针，**链表是动态的（dynamic），它能按照需要对表中的新元素分配空间**，由一系列被称为表的**结点（node）**的对象组成的
   - 单链表结点类（Link Node）

   ```cpp
   template<typename E>class Link{
   public:
       E element;
       Link *next;
       Link(){}
   }
   ```

   - 链表类（LinkedList）的私有数据成员

   ```cpp
   template<typename E>class LList{
    private:
        //头指针
        link<E>* head;
        //尾指针
        link<E>* tail;
        //当前指针，这个指针指向的是当前元素的前一个元素
        link<E>* curr;
   }
   ```

   - 带空头节点的链表  
     **有利于插入操作**，就不用判断 curr 当前结点是不是头结点
   - curr 指针
     **一般指向当前元素的前一个元素**

3. 可利用空间表（freelist）

   - 系统级别的 New 和 Delete 操作过于缓慢，链表类可以自己管理自己的分配和回收操作，使之高效。**使用 C++的操符重载（自己重新写 new 函数，系统级别使用::new（带两个冒号））**

   ```cpp
   template<typename E>class Link{
    private:
        static Link<E>* freelist;//声明成静态以后所有的Link都都共享这同一个可利用空间表
    public：
        //重载操作符new
        void* operator new(size_t){
        }
        //重载操作符delete
        void operator delete(){
        }
   }
   ```

4. 线性表的两种实现方法的比较(Comparison of Implementation）  
   Array-Based List:

   - 插入删除 O(n)
   - 前序和直接访问为 O(1)
   - 数组空间必须提前分配好（**空间大小固定**）
   - 如果数组满了，是没有开销的（overhead）

   Linked List：

   - 插入删除操作是 O(1)
   - 前序和直接访问是 O(n)
   - **空间随元素个数增长**
   - 每个元素都有额外开销

5. 双链表（doublely linked list）  
   这种链表允许直接访问当前指针的前驱节点，双链表的一个节点要存**两个地址空间，一个指向前驱节点，一个指向后继节点**  
   对应与单链表，双链表的区别：
   - 不仅有 head 头结点，还有 tail 尾结点，**都是空结点**
   - 插入删除操作比单链表多

###### 4.2 Stack(栈)

1. 定义
   - 栈是**限定只能在一端进行操作（插入删除）的线性表**
   - 具有**LIFO 的特性**（后进先出）
2. 栈的 ADT

```cpp
template<typename E>class stack{
public:
    //清空当前栈
    virtual void clear() = 0;
    //向栈内增加元素（压栈 入栈）
    virtual void push(const E& it) = 0;
    //弹出（删除）并返回栈顶元素，出栈
    virtual E pop() = 0;
    //返回当前栈顶元素的引用
    virtual const E& topValue() const = 0;
    //返回房前栈的大小（元素个数）
    virtual int length() = 0;
}
```

3. 顺序栈的实现

```cpp
template<typename E>
class AStack:public Stack<E>{
private:
    //栈的最大空间
    int maxSize;
    //top元素的index
    int top;
    //存储栈元素的数组
    E* listArray;
}
```

一般是在栈有 n 个元素时将位置 n-1 作为栈顶 top

4. 链式栈  
   不需要表头结点

```cpp
template<typename E>
class AStack:public Stack<E>{
private:
    //栈顶元素指针
    Link<E> *top;
    //栈的大小
    int size;
}
```

5. 递归的实现  
    使用栈可以消除递归
   **课本例子->使用栈实现阶乘**

```cpp
template<typename E>
long fact(int n, Stack<int>& S){
    Assert((n>=0)&&(n<=12), "input out of range!");

    while(n>1) S.push(n--);
    long result = 1;
    while(S.length() > 0)
        result *= S.pop();
    return result;
}
```

###### 4.3 quene(队列)

1. 定义
   - 队列也是受限制的线性表  
     只能在**队尾插入（入队 enquene） 和 队首删除（出队 dequene）**
   - 具有**FIFO 的特性**（先进先出）

###### 作业题

7．针对带表头结点的单链表，试编写下列函数。  
(1) 定位函数 Locate：在单链表中寻找第 i 个结点。若找到，则函数返回第 i 个结点的地址；若找不到，则函数返回 NULL。

```cpp
template<typename E>
Link<E>* locate(Link<E> *head, int i) {
    if(i<=0) return NULL;
    int count = 0;
    Link<E>* p = head;
    while(p->next != NULL){
        p = p->next;
        if (++count == i) return p;
    }
    return NULL;
}

template <typename E>
Link<E>* locate(Link<E> *head, const int index)
{
	if (index <= 0) return NULL;
	int n = 0;
	Link<E>* curr = head;
	while (curr->next != NULL)
	{
		curr = curr->next;
		if (++n == index) return curr;
	}
	return NULL;
}
```

(2) 求最大值函数 max：通过一趟遍历在单链表中确定值最大的结点。

```cpp
template<typename E>
Link<E>* max(Link<E> *head) {
    Link<E>* temp = head->next;
    Link<E>* p = head->next;
    while(p->next != NULL){
        if (p->element > temp->element)
            temp = p;
        p = p->next;
    }
    return temp;
}

template <typename E>
Link<E>* max(Link<E> *head)
{
	Link<E> *curr = head->next, *temp = head->next;
	while (curr->next != NULL)
	{
		curr = curr->next;
		if (curr->element > temp->element) temp = curr;
	}
	return temp;
}
```

(3) 统计函数 number：统计单链表中具有给定值 x 的所有元素。

```cpp
template<typename E>
int number(Link<E> *head, const E& x) {
    int count = 0;
    Link<E>* p = head->next;
    while(p->next != NULL){
        if(p->element == x)
            count++;
        p = p->next;
    }
    return count;
}

template <typename E>
int number(Link<E> *head, const E& value)
{
	int num = 0;
	Link<E>* curr = head->next;
	while (curr->next != NULL)
	{
		curr = curr->next;
		if (curr->element == value) num++;
	}
	return num;
}
```

(4) 建立函数 create：根据一维数组 a[n]建立一个单链表，使单链表中各元素的次序与 a[n]中各元素的次序相同，要求该程序的时间复杂性为 O(n)。

```cpp
template<typename E>
Link<E>* create(E a[],int n) {
    if(n == 0) return NULL;
    Link<E> *head, *curr;
	head = curr = new Link<E>();

    for(int i=0; i<n; i++){
        curr->next = new Link<E>(a[i]);
		curr = curr->next;
    }
    return head;
}

template <typename E>
Link<E>* create(E *a, int n)
{
	if (n == 0) return NULL;
	Link<E> *head, *curr;
	head = curr = new Link<E>();
	for (int i = 0; i < n; i++)
	{
		curr->next = new Link<E>(a[i]);
		curr = curr->next;
	}
	return head;
}
```

(5) 整理函数 tidyup：在非递减有序的单链表中删除值相同的多余结点。

```cpp
template<typename E>
void tidyup(LLink<E>* list) {
    if(list == NULL) return -1;
    LLink<E>* p = list;
    list->moveToStart();

    for(int i=0; i<n; i++){
        list->insert(a[n]);
    }
    return list;
}

template <typename E>
void tidyup(Link<E> *head)
{
	Link<E> *curr = head->next;
	int temp = curr->element;
	while (curr->next != NULL)
	{
		if (curr->next->element == temp)
			curr->next = curr->next->next;
		else
		{
			curr = curr->next;
			temp = curr->element;
		}
	}
}
```

##### Chapter 5 二叉树 Binary Tree

###### 5.1 定义

1. 二叉树  
   二叉树（binary tree）是由结点（node）的**有限**集合组成，这个集合可以是**空（empty）**或者一个**根结点（root）**及两棵不相交的二叉树组成（**左边叫左子树（left subtree），右边叫右子树（right subtree）**）

2. 深度（depth）和高度（height）  
   **深度：结点 M 的深度就是从根到该结点的路径长度**  
   **高度：树的高度就是最深结点的深度+1**

3. 满二叉树（Full）和完全二叉树（complete）  
   **满二叉树：每一个结点要么是叶结点（没有 children）要么是有两个非空子结点的内部结点（两个 children）**，**_0 或两个子结点_**  
   **完全二叉树：除了最下面的一层，其他每一层都是满的，最下面一层的叶子结点都在左边**

4. 满二叉树定理  
   对于满二叉树来说，**叶子结点 = 内部结点+1**  
   推论：**树中的空指针 = 结点数+1**

5. 二叉树的性质

   - 在二叉树的第 i 层上至多有 2^(i-1)个结点
   - 深度为 k 的二叉树至多有 2^k-1 个结点
   - 对于任何一棵二叉树而言，叶子结点的数量是度为 2 的结点数量+1（特别地，满二叉树）
   - 具有 n 个结点的完全二叉树的深度为 log2 N +1

6. 完全二叉树的性质
   完全二叉树每一层结点数量最多是 2^i,i 为深度
   完全二叉树最多拥有 2^k-1 个结点，k 为高度

7. 二叉树结点的 ADT（**BinNode**）

```cpp
template <typename E> class BinNode{
public:
    //Base destructor 基本析构函数
    virtual ~BinNode(){};
    //return the node's value 返回结点的值（数据）
    virtual E& element() = 0;
    //set the node's value 给结点设置值（数据）
    virtual void setElement(const E&) = 0;
    //return the node's left children 返回结点的左孩子结点
    virtual BinNode* left()=0;
    //set the node's left children 给结点设置左孩子结点
    virtual setLeft(BinNode*) = 0;
    //return the node's right children 返回结点的右孩子结点
    virtual BinNode* right() = 0;
    //set the node's right children 给结点设置右孩子结点
    virtual setRight(BinNode*) = 0;
    //return true if the node is a leaf,false otherwise 结点是叶结点返回true，否则返回false
    virtual isLeaf()=0;

}
```

###### 5.2 二叉树的遍历（Traversal）

    按照一定的顺序访问二叉树的所有结点，叫做一次**遍历（Traversal）**， **什么时候访问根结点就是什么遍历**

1. 前序遍历（preorder traversal）  
   先访问**根结点**，再访问**左结点**，再访问**右结点**

2. 中序遍历（inorder traversal）  
   先访问**左结点**，再访问**根结点**，再访问**右结点**

3. 后序遍历（postorder traversal）  
   先访问**左结点**，再访问**右结点**，再访问**根结点**

4. 前序遍历的实现(递归法)

```cpp
template<typename E>
void preorder(BinNode<E>* root){
    if(root == null) return;
    visit(root);
    //先做合法性检查
    preorder(root->left());
    preorder(root->right());
}
```

    更换visit的位置就能实现前序、中序、后序遍历

5. 课本例子

- 计算一个二叉树中的结点数量

```cpp
template<typename E>
int count(BinNode<E>* root){
    if(root == null) return 0;
    //注意要有1哈哈哈
    return 1 + count(root->left()) + count(root->right());
}

```

- 计算一个树的的深度

```cpp
template<typename E>
int deep(BinNode<E>* root){
    if(root == null) return 0;
    //注意要有1哈哈哈
    return 1 +
        deep(root->left()) > deep(root->right()) ? deep(root->left()) : deep(root->right());
}

```

###### 5.3 二叉树的实现

1. 使用指针实现（Point）  
   对于每个结点：

   - 数据域
   - 左子树指针
   - 右子树指针

2. 表达式树可以使用 Union 实现

   ```cpp
   union{//枚举类型可挑选内部结点或者叶结点进行单一实现
       struct{//内部结点，操作符
           BinNode* left;
           BinNode* right;
           Operator opx;
       }intl;
       Oprand var;//叶结点，操作数
   }
   ```

3. 空间代价  
   **结构性开销：为了实现数据结构所花费的空间**  
   二叉树：P（指针域空间），D（数据域空间）。Overhead：2P/（2P+D）

4. 使用数组来实现完全二叉树  
   树的形状直接由数组的**下标**来确定
   ![pic5.3](https://pic.downk.cc/item/5f9815871cd1bbb86b2eac19.png)

###### 5.4 BST 二叉检索树(Binary Search Tree)

1. 定义  
   **_在二叉检索树中，每一个结点 K，它的左子树中所有的值都小于 K，右子树中所有的值都大于等于 K_**  
   特点：**中序遍历得到的序列，就是从小到大排序的序列**

2. BST ADT

```cpp
//二叉检索树（BST）的ADT
template <typename Key, typename E>
class BST : public Dictionary <Key, E>{
private:
	//二叉检索树的根
	BSTNode<Key, E>* root;
	//BST结点的总数
	int nodecount;

	//受保护的帮助函数
	void clearhelp(BSTNode<Key, E>*);
	BSTNode <Key, E>* inserthelp(BSTNode <Key, E>*, const Key&, const E&);
	BSTNode <Key, E>* deletemin(BSTNode <Key, E>*);
	BSTNode <Key, E>* removehelp(BSTNode <Key, E>*, const Key&);
	E findhelp(BSTNode <Key, E>*, const Key&) const;
	void printhelp(BSTNode <Key, E>*, int) const;

public:
	BST() { root = NULL; nodecount = 0; }//构造函数
	~BST() { clearhelp(root); }//析构函数

	//重新初始化这个BST
	virtual void clear() = 0;

	//插入一个记录在数里
	//k 需要插入的数据的键值
	//e 需要被插入的数据
	virtual void insert( const Key& k, const E& e) = 0;

	//从树中移除一个数据
	//k 要被移除的数据都键值
	//返回被移除的数据，如果那个位置为空的话返回NULL
	virtual E remove(const Key& k) = 0;

	//从字典的跟结点中移除并返回一个数据
	//返回被移除的数据， 如果树为空则返回NULL
	virtual E removeAny() = 0;

	//返回键值为k的数据，如果没有则返回NULL
	//k ：需要查找的数据的键值
	//返回一些匹配到k的数据
	//返回True如果这样的值存在的话，不存在则返回False
	//如果存在多个，返回其中随机的一个
	virtual E find(const Key& k) const = 0;

	//返回字典中记录的数量
	virtual int size() = 0;

	//打印这个BST
	virtual void print() const = 0;
}
```

3. BST 操作
   - 插入  
      把要插入的值与根结点做比较，如果比根结点小就找左子树，如果大于等于根结点就找右子树。递归调用即可实现。
   - 删除  
      删除的如果是一个叶结点，就直接删掉，如果是一个内部结点，那就要从右子树中找到一个最小值来补到这个位置上来

###### 5.5 堆和优先队列(Heap & Priority Queues)

1. 定义

   - 堆是一种完全二叉树
   - 最大堆（max heap）：任何一个结点的值都大于等于它的子结点的值（**因此跟结点是全堆的最大值**）
   - 最小堆（min heap）：任何一个结点的值都小于等于它的子结点的值（**因此跟结点是全堆的最小值**）

2. heap ADT

```cpp
template <typename E, typename Comp> class heap{
private:
	//堆数组的指针
	E* Heap;
	//堆的最大范围
	int maxsize;
	//堆中目前元素的数量
    int n;

	//把一个元素放到它合适位置的函数
	void siftdown(int pos){
		while (!isLeaf(pos)){//不是叶结点
			int j = leftchild(pos);
			int rc = rightchild(pos);

			if((rc < n) && Comp::prior(Heap[rc], Heap[j]))
				j = rc; //将j设置为更大的子元素值

			swap (Heap, pos, j);
			pos = j;

		}
	}
public:
	//构造函数
	heap(E* h, int num, int max)
		{ Heap = h; n = num; maxsize = max; buildHeap(); }

	//返回当前堆堆大小
	virtual int size() const = 0;

	//如果pos是叶子则返回True
	virtual bool isLeaf(int pos) const = 0;

	//返回当前位置的左孩子
	virtual int leftchild(int pos) const = 0;

	//返回当前位置的右孩子
	virtual int rifgtchild(int pos) const = 0;

	//返回父亲结点的位置
	virtual int parent(int pos) const = 0;

	//建堆
	virtual void buildheap() = 0;

	//插入item到堆里
	void insert(const E& item){
		Assert(n < maxsize, "Heap is full");
		int curr = n++;
		Heap[curr] = item; //开始只能把item放到堆的最后面

		//现在把它向上排，知道curr的父亲结点大于curr
		while( (cuur != 0) && (Comp:prior(heap[curr], Heap[parent(curr)] ) )){
			swap(Heap, curr, parent(curr));
			curr = parent(curr);
		}
	}

	//删除第一个元素, 并返回删掉的元素
	E removefirst(){
		Assert(n > 0, "Heap is empty");
        //先把它和最后一个元素交换，并且n-1，可以相当于删除元素（实际还在最后在着但我们一斤不管他来）
		swap(Heap, 0, --n);
        //然后对跟结点进行siftdown操作即可
		if(n != 0) siftdown(0);
        //返回最后一个元素（被删掉的元素）
		return Heap[n];
	}


	//删除特定位置的元素
	E remove (int pos){
		Assert((pos >= 0) && (pos < n), "Bad position");

		if(pos == (n-1) ) n--;//最后一个元素，没有什么可操作的
		else
		{
			swap(Heap, pos, --n);
			while((pos != 0) && (Comp:: prior(Heap[pos], Heap[parent(pos)])))
			{
				swap(Heap, pos, parent(pos));//把大的元素往上移动
				pos = parent(pos);
			}
			if( n != 0) siftdown(pos); //把小的元素下移
		}
		return Heap[n];
	}
};
```

3. heap constructor 堆构造器

   - constructor：直接使用无序数组到堆里，建立起完全二叉树
   - buildHeap：建堆，从后向前检查每一个内部结点，对其进行 siftdown
   - siftdown：在子树中调整 root，leftchild，rightchild 三者的大小，选出最大（小）的换到 root 上  
     构造过程：  
     **constructor -> buildHeap -> siftdown**

4. 堆的时间复杂度

   - 建堆 buildHeap：O(n)
   - 删除一个元素 remove：最差 O(log n)
   - 插入一个元素 insert：O(log n), 插入 n 个元素 O(nlog n)

5. **Priority Queues 优先队列**  
   一些按照重要性或优先级来组织的对象称为优先队列
   - **要求是要能快速释放最大值（如最高优先级）的对象**
   - **优先级可能会改变，要求要能重新排序这些任务（动态）**
   - Example：多任务操作系统的调度工作
   - Implementation：**Heap**

###### 5.6 huffman Coding Tree 哈夫曼编码树

1. 定长编码和变长编码

   - 定长编码：每个字符的编码大小都是固定的（比如都是 8bits），**如果每个字符的使用频率都相等，那么固定长度的编码是空间效率最好的方法**
   - 变长编码：每种字符的编码大小是不固定的，根据某种规则来规定其编码大小，比如哈夫曼编码。**根据字符使用频率来进行编码**

2. Definition 定义

   - **weight 权重**： 字符使用频率，对于哈夫曼树，叶结点才有权重
   - 叶结点**加权路径长度**：叶结点的权重乘以深度

3. huffman Tree Construction 哈夫曼树的构造-->贪心算法

   - 每次选取拥有最小权值的两个结点，将其结合
   - 结合以后要重新排序
   - 内部结点只有权值没有 value

4. huffman coding & decoding 哈夫曼编码和解码

   - 编码  
     哈夫曼树形成后，左路径都是 0，右路径都是 1。将编码后的对应表写出来
   - 解码
     直接使用原信息序列在哈夫曼树上走，每次走到一个跟结点就能解码出一个字符

5. 哈夫曼编码常考

   - 每个字母的期望代码长度  
      （每个字母出现的次数\*它的编码长度）/总的字母个数

6. huffman Node calss 哈夫曼结点类

```cpp
//哈夫曼树结点的类ADT
template <typename E> class HuffNode{
public:
	//基本析构函数
	virtual ~HuffNode (){}
	//返回权重
	virtual int weight() = 0;
	//判断是不是叶结点
	virtual bool isLeaf() = 0;
}

//哈夫曼树叶结点类实现
template <typename E>
class LeafNode : public HuffNode<E>{
private:
	//叶结点的值
	E item;
	//叶结点的权重
	int wht;
public:
	//构造函数
	virtual LeafNode (const E& val, int freq) = 0；
	//返回权重
	virtual int weight() = 0;
	//返回结点的值
	virtual E val() = 0;
	//判断是不是叶结点
	virtual bool isLeaf() = 0;
}

//内部结点子类实现
template <typename E>
class IntlNode : public HuffNode<E> {
private:
	//结点的左孩子
	HuffNode<E>* lc；
	//结点的右孩子
	HuffNode<E>* rc;
	//子树的权重
	int wgt;

public:
	//构造函数
	virtual IntlNode(HuffNode<E>* l, HuffNode<E>* r) = 0;
	//返回权重
	virtual int weight () = 0;
	//判断是不是叶结点
	virtual bool isleaf() = 0;

	//返回结点的左孩子
	virtual HuffNode<E>* left() const = 0;
	//设置结点的左孩子
	virtual void setLeft(HuffNode<E>* b) = 0;
	//返回结点的右孩子
	virtual HuffNode<E>* right() const = 0;
	//设置结点的右孩子
	virtual void setRight(HuffNode<E>* b) = 0;

}
```

6. Huffman Tree Impletation 哈夫曼树实现

```cpp
//哈夫曼树是由两个参数构成的
//类型被编码和一个比较器和两个同样的参数
template <typename E>
class huffTree{
private:
	//树的根
	HuffNode<E>* Root;
public:
	//树叶结点的构造函数
	virtual HuffTree(R& val, int freq) = 0;
	//内部结点的构造函数
	virtual HuffTree(HuffNode<E>* l, HuffNode<E>* r) = 0;
	//析构函数
	virtual ~HuffTree(){}
	//得到根结点
	virtual HuffNode<E>* root() = 0;
	//根结点的权重
	virtual int weught() = 0
}


//建造一个哈夫曼树 这是一个函数
//使用大顶堆来建造哈夫曼树，每次取出两个最小权重的结点，构造成树以后在把它插回去
template <typename E>
HuffTree<E>* buildHuff(HuffTree<E>** , TreeArray, int count){
	heap <HuffTree<E>*, minTreeComp>* forest= new heap<HuffTree<E>* , MinTreeComp> (TreeArray, count, count);
    //临时变量
	HuffTree<char> *temp1, *temp2, *temp3 = NULL;

	while(forest-> size() > 1){
		//把第一个结点放到树里
		temp1 = forest->removefirst();
		//off the list
		temp2 = foresr->removefirst();

		temp3 = new HuffTRee<E> (temp1, temp2);
		//把这个新的树返回到列表里
		forest->insert(temp3);
		delete temp1;
		delete temp2;
	}
	return temp3;
}
```

###### 第五章作业题

```cpp
void showTreeUsingLink(TreeNode<E>* root, int level=1){
    if(root == NULL) return 0;
    else{
        showTreeUsingLink(root->right(), level+1);
        cout << endl;
        for(int i=0; i< level-1; i++)
            cout << " ";
        cout << root->value();
        showTreeUsingLink(root->left(), level+1);
    }
}

int countLeaf(TreeNode<E>* root)//分治法统计叶子节点数目
{
    int count;
    if(root==NULL)
        count=0;
    else if(root->left()==NULL && root->right()==NULL)
        count=1;
    else
        count=countLeaf(root->left())+countLeaf(root->right());
    return count;
}

void change(TreeNode<E>* root){
    if (root->right() == NULL && root->left() == NULL){
        return;
    }
    TreeNode<E>* temp;
    temp = root->left();
    root->left() = root->right();
    root->right() = temp;

    if (root->left()){
        change (root->left());
    }
    if (root->right()){
        change (root->right());
    }
}

template<typename E>
void travelIteratively(BinNode<E>* root){
    Queque<BinNode<E>*> nodeQueue = new Queque<BinNode<E>*>();
    nodeQueue.push(root);
    while(!nodeQueue.empty()){
        root=nodeQueue.front();
        if(root!=null){
            cout<<root->value()<<" ";
            nodeQueue.push(root->left());
            nodeQueue.push(root->right());
        }
        nodeQueue.pop();
    }
}

bool isValidBST(BinNode<E>* root, int min, int max){
        if(root == NULL)
            return true;
        if (min < root->val && root->val < high)
            return (isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, high));
        else
            return false;
    }

template<typename E>
void isValidBST(BinNode<E>* TreeTop) {
    //用非递归中序遍历得到二叉树的序列
	stack<BinNode<E>*> STN;
    E A[100];
    int index=0;
	STN.push(TreeTop);
	while (STN.size()) {
		BinNode<E>* Top = STN.top();
		if (!Top.State) {
			a[index] = STN.pop()->element();
            index++;
			Top.State = 1;
			STN.push(Top);
			if (Top.rightNode) {
				a[index] = STN.pop()->element();
                index++;
				STN.push(*Top.rightNode);
				STN.push(Top);
			}
			if (Top.leftNode) {
				STN.push(*Top.leftNode);
			}
		}
		else {
			cout << Top.getName() << ends;
			a[index] = STN.pop()->element();
            index++;
		}
	}
    //BST应满足该序列为递增序列
    for(int i=0;i<index; i++)
        if(a[i]>a[i+1]) return false;
}
```

##### Chapter 6 树 General Tree

###### 6.1 定义

1. General Tree 通用树  
   不限制一个结点有几个子结点

2. 树结点的 ADT

```cpp
//树结点的ADT
template <typename E> class GTNode{
public:
	//返回结点的值
	E value();
	//判断是否是叶结点
	bool isLeaf();
	//返回父亲结点
	GTNode* parent();
	//返回坐左边的第一个孩子结点
	GTNode* leftmostChild();
	//返回右边的兄弟姐妹
	GTNode* rightSibling();
	//设置结点的值
	void setValue(E&);
	//插入第一个孩子
	void insertFirst(GTNode<E>*);
	//插入后面的兄弟姐妹
	void insertNext(GTNode<E>*);
	//移除第一个孩子
	void removefirst();
	//移除右边的兄弟姐妹
	void removeNext();
};


//一般树的ADT
template<typename E> class GenTree{
public:
	//清除所有结点并释放空间
	void clear();
	//返回树的根结点
	GTNode<E>* root();
	//联合两棵子树
	void newroot(E&, GTNode<E>*, GTNode<E>*);
	//画出一棵树
	void print();
};
```

3. 树的遍历  
   一般不使用树的中序遍历，只在乎前序和后序遍历（先根后根）。

4. 课本例子->使用**前序遍历**的遍历树

```cpp
template<typename E>
   void print(GTNode<E>* root){
       //如果目前的根是叶结点，那就输出Leaf，如果是内部结点那就输出Internal
       if(root->isLeaf()) cout << "Leaf:";
       else cout << "Internal:";
       //访问当前结点的值
       cout << root->value() << endl;
       //使用循环和递归来访问它的所有子结点
       for(GTNode<E>* temp = root->leftmostChild(); temp != NULL; temp = temp->rightSibling())
        print(temp);
   }
```

###### 6.2 父指针表示法

1. 定义  
   对树的每一个结点只保存一个指针域->**指向父结点**，这个指针叫做父指针，有利于**并查算法**
   - 并查算法：用一棵树代表一个集合

###### 6.3 树的实现

1. 子结点表表示法

   - 下标从 0 开始，0 为根结点
   - 第一列为当前结点的值 Val
   - 第二列为父结点的下标 Par
   - 第三列为指向孩子结点的指针域，链接下去的结点的链表 value 存子结点的下标
     ![pic6.1](https://pic.downk.cc/item/5fabaff41cd1bbb86bfda058.jpg)

2. 左子结点/右兄弟结点表示法

   - 下标从 0 开始，0 为根结点
   - 第一列为当前结点的左子结点的下标 Left
   - 第二列为当前结点的值 Val
   - 第三列为父结点的下标 Par
   - 第四列为右兄弟结点的下标
     ![pic6.2](https://pic.downk.cc/item/5fabb12b1cd1bbb86bfde1d7.jpg)

3. 动态结点表示表示法
   ![pic6.3](https://pic.downk.cc/item/5fabb1751cd1bbb86bfdf00e.jpg)
   ![pic6.4](https://pic.downk.cc/item/5fabb19d1cd1bbb86bfdf9e9.jpg)

###### 6.5 树的顺序实现方法

![pic6.5](https://pic.downk.cc/item/5fabb27c1cd1bbb86bfe22e4.jpg)

1. 用/代表 NULL 指针  
   **AB/D//CEG///FH//I//**  
   解析的时候遵循根->左->右的顺序，若一个结点满了则返回到上一层开始画

2. 内部结点使用（'）进行标记  
   **A’B’/DC’E’G/F’HI**

3. 对于一个通用树来说，可以用）来表示它是一个叶结点  
   **RAC)D)E))BF)))**

##### Chapter 7 内排序

###### 7.2 三种时间代价为 O(n^2)的排序

1. 插入排序
2. 冒泡排序
3. 选择排序

   - 每次从后面的 n-i 个里找到一个最小值，用一个 index 记录它，每一趟完成以后 将其与第一个元素交换  
     **不稳定**:在排序完成后，原本相等的两个数可能会交换位置
   - code

   ```cpp
   template<typename E, typename Comp>
   void selsort(E A[], int n){
       for(int i=0; i<n; i++){
           int index=i;
           for(int j=n-1; j>i;j++){
               if(a[j] < a[index])
                index = j;
           }
           swap(a, i, index)
       }
   }
   ```

4. 时间代价问题

###### 7.3 shell 排序

1. 定义  
   也叫**缩小增量排序**， 基本思想是对排序序列先做宏观调整，再做围观调整

2. 操作  
   将所有的 n 个记录分成 d 个子序列（d 组），**d 就是增量， 他的大小会在排序过成中逐渐减小，直到最后一次他会变成 1**  
   在每一趟的排序里，就是一次简单的插入排序

3. shell 排序的实现

```cpp

template<typename E, typename Comp>
void inssort2(){


}
//shell排序的实际就是分成一些小的插入排序
template<typename E, typename Comp>
void shellsort(E A[], int n){


}
```

###### 7.5 Quick 快速排序

1. 操作  
   寻找一个**枢轴**， 比他小的移动到他左边，比他大的移动到它右边，之后在左右两部分中再次使用这个方法（递归）

2. 实现

##### Chapter 8 文件管理和外排序

###### 8.1 主存和辅存

1. 数据结构和文件结构

   - 数据结构是数据在**内存（main memory RAM）**上的存储结构
   - 文件结构是数据在**辅存（secondary memory）**上的存储结构

2. 内存和辅存

   - 内存：**_RAM_**易失（**volatile**）在关闭电源以后回失去数据存储
   - 辅存：硬盘、磁盘、光盘，具有永久储存的能力，代价是访问时间更长

3. 磁盘设计原则  
   **使磁盘的访问次数最少**，因为从磁盘读取数据是一个 IO 操作，花费大量时间

   - 方法 1:合适安排信息的位置，以最少的当问次数就能得到所需要的数据。  
      **文件结构（file structrue）：对于在辅助存储器中的数据，其数据结构就成为文件结构，文件结构的组织应当使磁盘访问次数最少**

   - 方法 2:使用缓冲技术  
      通过少量的额外开销预测未来将要被使用的数据，在一次 IO 中也加载到内存  
      **缓存技术：保存之前的访问信息，从而减少当年的访问需要**

###### 8.2 磁盘

1. 逻辑文件和物理文件

   - 逻辑文件（logic file）：程序员把存储在磁盘中可以随机访问的文件看成一段连续的字节，**而且可以把这些字节结合起来构成记录，这叫逻辑文件**
   - 物理文件（physical file）：通常不是一段连续的字节，**而是成块分布在整个磁盘中**

2. 文件管理器（file manager）  
   是操作系统的一部分，当进行文件请求时，实现**应用程序请求从逻辑文件中读取数据时，它把逻辑位置映射为磁盘的具体位置**

3. 磁盘结构

   - 盘片 Platter
   - 主轴 spindle
   - 读写头 read/write head（IO head）
   - **扇区 sector：IO 的基本单位**
   - 磁道 track：盘片上的一个同心圆环
   - 扇区间间隙：intersector gap：磁头通过间隙来识别扇区的结束
   - **交错因子 interleaving factor：**  
     **在一个磁道上，逻辑上相邻的两个扇区的物理实际距离**
   - **簇 cluster**  
     **多个扇区的组，是文件分配的基本单位，由文件管理器的文件分配表（File Allocation Table）来记录每个文件是由那些簇组成的**
   - **引用局部性**  
      当在磁盘上的记录被读时，下一个请求很有可能是来自这个文件中的附近的位置
   - 内部碎片（internal fragmentation）  
      一些没有被使用然而不会被用到的剩余空间

4. 磁盘访问代价
   - **寻道时间（seek time）**：磁头找到相应磁道的时间，**是磁盘 IO 的主要代价**
   - **旋转延迟（rotation delay or latency）**：**取平均旋转延迟为磁盘转半圈的时间**，for7200rpm， this is 8.3/2=4.2ms
   - 数据传输时间：实际传输读写数据的时间

###### 8.3 缓冲区和缓冲池（Buffer）

1. 缓冲区  
   在一次 IO 的时候通常会将整个扇区的内容都读取到内存中

2. 缓冲池  
   一系列的缓冲区组成的缓冲池

3. 置换策略
   - FIFO 先进先出
   - LFU 最不频繁使用法
   - LRU 最近最少使用法

###### 8.5 外排序

1. 定义  
   数据太大了内存装不下，要排序它，必须把一部分取到内存，处理，再写回去。**外排序必须最小化磁盘访问**

   - 把文件分成尽量大的初始顺串
   - 把所有顺串归并到一起，形成一个已排序的文件

2. 置换选择排序
