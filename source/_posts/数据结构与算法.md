title: 数据结构与算法
author: Micah
date: 2020-09-26 18:52:04
tags:

---

#### 课程介绍

- 继续刷分

#### 课程考核

#### content

##### Chapter 1 Data Structures and algrothm

###### 1.1 data structure 数据结构

1. data structure 数据结构  
   定义：一类数据的表示和其相关的操作  
   任何记录的组织（数据结构），都要能够进行**增删改查**的操作

2. Efficiency 效率  
   一个算法（solution）如果能在所要求的**资源限制（resource constraint）**内解决好，那么他就是**有效的（efficient）**。

3. 数据结构的选择

   - 分析问题。**找到解决方案（算法）必须满足的资源限制**
   - 决定所支持的基本操作（增删查等行为），衡量每种操作的资源限制
   - 选择最接近这些代价的数据结构

4. Philosophy  
   **没有任何一种数据结构在所有情况（situation）都比其他都优秀**：  
   每种数据结构都有它在时间和空间上的资源限制，只有在仔细分析问题的特征之后，我们才能知道最适合这个工作的是哪一种数据结构。

###### 1.2 ADT 抽象数据类型

1. ADT definition

   - ADT：一个**类型（type，一组值的集合）**，和定义在这个类型上的**操作（operation）**。
   - 每一种操作由他的**输入输出（input & output）**来定义。
   - 封装（encapsulation）：对外隐藏实现操作的细节。

   ![pic1](https://pic.downk.cc/item/5f7c11d6160a154a67e8b6c0.png)

2. Data Structure

   - **数据结构是 ADT 的物理实现**， ADT 的每种操作都会有一种或多种具体实现。
   - **数据结构**指的是在**内存**中数据的组织
   - **文件结构**指的是在**辅存**中数据的组织

3. Logical vs Physical Form 数据形式和物理形式  
   Data items have both a logical and a physical form  
   数据项同时具有**逻辑和物理**两种形式。

   - Logical form: definition of the data item within an ADT.  
     逻辑形式：利用 ADT 给出的数据项的定义。
   - Physical form: implementation of the data item within a data structure.  
     物理形式：数据结构中对数据项的实现。

   ![pic2](https://pic.downk.cc/item/5f7c1164160a154a67e89d08.png)

4. Vital features
   - 数据抽象: 用 ADT 描述程序处理的实体时，强调的是**其本质的特征、其所能完成的功能以及它和外部用户的接口**（即外界使用它的方法）。
   - 数据封装: 将实体的外部特性和其内部实现细节分离，并且**对外部用户隐藏其内部实现细节。**

###### 1.4 Problem、algrithm、program 问题、算法和程序

1. Problem 问题 ：**需要执行的任务**

   - 最好的想法是**对应一组输入，就有一组相应对输出**。
   - 问题定义应该包含**对任何可行方案所需对资源限制**。

2. Algorithm 算法：**解决一个问题的方法或过程**

   - 算法的任务就是把输入转换成输出
   - 一个问题有多种算法
   - 算法应该具有的性质：
     1. 正确性（correct）
     2. 具体步骤（concrete step）
     3. 确定性（no ambiguity 无二义性）
     4. 有限性（finite）
     5. 可终止性（terminate）

3. Program 程序  
   A computer program is an instance, or concrete representation, for an algorithm in some programming language.  
   一个计算机程序是**使用某种程序设计语言对一个算法对具体实现（或一种实例）**。

##### Chapter 2 Mathmatical Background

###### 2.4 级数求和

![pic3](https://pic.downk.cc/item/5f7c18a0160a154a67ea5f76.png)

###### 2.5 Recursion 递归

一个算法调用自己来完成它的部分工作，在解决某些问题时，一个算法需要调用自身。**如果一个算法直接调用自己或间接地调用自己，就称这个算法是递归的(Recursive)。**
根据调用方式的不同，它分为

- 直接递归(Direct Recursion)
- 间接递归(Indirect Recursion)

##### Chapter 3 Algorithm Analyse 算法分析

###### 3.1 Introduction

1. 增长率（growth rate）  
   当问题的规模（size）增大时，算法代价增长的速度。

2. 算法分析要包括两方面

   - 时间代价
   - 空间代价

3. Measure Efficientcy 效率的度量  
   处理一定**规模（size）**时，该算法所需要的**基本操作（basic operation）**的数目。  
   基本操作的条件：完成该操作所需时间与操作数的具体取值无关。

4. 增长率分类
   - linear growth rate / linear time cost 线性增长率（线性函数，cn）
   - quadratic growth rate （二次增长率 n^2）
   - exponential growth rate (指数增长率 2^n， n！)

###### 3.4 渐进分析

```
忽略系数
```

1. upper bound 上限  
   大 O 表示法：描述的是最大资源代价

2. lower bound 下限  
   大 omega 表示法：描述的是最小资源代价

##### Chapter 4 List、Stacks and Queue

###### 4.1 List(线性表)

1. 定义

   - 线性表是由元素（element）的数据项组成的一种**有序且有限**的序列
   - List elements have a position(位序)
   - 线性表有两种实现**_顺序表（sequential list）和链表（Linked list） _**

2. List ADT:

```cpp
template <class Elem> class List{
public:
    //清空线性表的内容
    virtual void clear()=0;
    //在当前位置插入一个元素
    virtual bool insert(const E& item)=0;
    //在线性表的最后插入一个元素
    virtual bool append(const E& item)=0;
    //在当前位置删除一个元素
    virtual E remove()=0;
    //把当前位置设置为线性表的开头
    virtual void moveToStart()=0;
    //把当前位置设置为线性表的最后
    virtual void moveToEnd()=0;
    //跳转到前一个元素
    virtual void prev()=0;
    //跳转到下一个元素
    virtual void next()=0;
    //返回线性表的长度
    virtual int Length() const =0;
    //返回当前元素的位置
	virtual int currPos() const = 0;
	//设置当前位置
	//Pos为你想设置的位置
	virtual void moveToPos (int Pos) = 0;
	//返回当前元素的值
	virtual const E& getValue() const = 0;
}
```

1. 顺序表（sequential List ｜ array based list）

   - 顺序表是基于数组来实现的,顺序表的私有成员如下

   ```cpp
   template<typename E>
   class AList:public List<E>{//表示AList是由List类继承来的
    private:
        int maxSize;//该顺序表能拥有的最大元素个数
        int listSize;//当前表中的元素个数
        int curr;//当前位置
        E* listArray;//支持顺序表的数组（核心）
   }
   ```

2. 链表（Linked List）

   - 定义：使用指针，**链表是动态的（dynamic），它能按照需要对表中的新元素分配空间**，由一系列被称为表的**结点（node）**的对象组成的
   - 单链表结点类（Link Node）

   ```cpp
   template<typename E>class Link{
   public:
       E element;
       Link *next;
   }
   ```

   - 链表类（LinkedList）的私有数据成员

   ```cpp
   template<typename E>class LList{
    private:
        //头指针
        link<E>* head;
        //尾指针
        link<E>* tail;
        //当前指针，这个指针指向的是当前元素的前一个元素
        link<E>* curr;
   }
   ```

   - 带空头节点的链表  
     **有利于插入操作**，就不用判断 curr 当前结点是不是头结点
   - curr 指针
     **一般指向当前元素的前一个元素**

3. 可利用空间表（freelist）

   - 系统级别的 New 和 Delete 操作过于缓慢，链表类可以自己管理自己的分配和回收操作，使之高效。**使用 C++的操符重载（自己重新写 new 函数，系统级别使用::new（带两个冒号））**

   ```cpp
   template<typename E>class Link{
    private:
        static Link<E>* freelist;//声明成静态以后所有的Link都都共享这同一个可利用空间表
    public：
        //重载操作符new
        void* operator new(size_t){
        }
        //重载操作符delete
        void operator delete(){
        }
   }
   ```

4. 线性表的两种实现方法的比较(Comparison of Implementation）  
   Array-Based List:

   - 插入删除 O(n)
   - 前序和直接访问为 O(1)
   - 数组空间必须提前分配好（**空间大小固定**）
   - 如果数组满了，是没有开销的（overhead）

   Linked List：

   - 插入删除操作是 O(1)
   - 前序和直接访问是 O(n)
   - **空间随元素个数增长**
   - 每个元素都有额外开销

5. 双链表（doublely linked list）  
   这种链表允许直接访问当前指针的前驱节点，双链表的一个节点要存**两个地址空间，一个指向前驱节点，一个指向后继节点**  
   对应与单链表，双链表的区别：
   - 不仅有 head 头结点，还有 tail 尾结点，**都是空结点**
   - 插入删除操作比单链表多

###### 4.2 Stack(栈)

1. 定义

   - 栈是**限定只能在一端进行操作（插入删除）的线性表**
   - 具有**LIFO 的特性**（后进先出）

2. Stack's ADT

```cpp
template<typename E>class stack{
public:
    //清空当前栈
    virtual void clear() = 0;
    //向栈内增加元素（压栈 入栈）
    virtual void push(const E& it) = 0;
    //弹出（删除）并返回栈顶元素，出栈
    virtual E pop() = 0;
    //返回当前栈顶元素的引用
    virtual const E& topValue() const = 0;
    //返回房前栈的大小（元素个数）
    virtual int length() = 0;
}
```

3. 顺序栈的实现

```cpp
template<typename E>
class AStack:public Stack<E>{
private:
    //栈的最大空间
    int maxSize;
    //top元素的index
    int top;
    //存储栈元素的数组
    E* listArray;
}
```

一般是在栈有 n 个元素时将位置 n-1 作为栈顶 top

4. 链式栈  
   不需要表头结点

```cpp
template<typename E>
class AStack:public Stack<E>{
private:
    //栈顶元素指针
    Link<E> *top;
    //栈的大小
    int size;
}
```

5. 递归的实现  
    使用栈可以消除递归
   **课本例子->使用栈实现阶乘**

```cpp
template<typename E>
long fact(int n, Stack<int>& S){
    Assert((n>=0)&&(n<=12), "input out of range!");

    while(n>1) S.push(n--);
    long result = 1;
    while(S.length() > 0)
        result *= S.pop();
    return result;
}
```

###### 4.3 quene(队列)

1. 定义

   - 队列也是受限制的线性表  
     只能在**队尾插入（入队 enquene） 和 队首删除（出队 dequene）**
   - 具有**FIFO 的特性**（先进先出）
   - 第一个元素：Front（马上要出队的）
   - 最后一个元素：Rear（刚进来的）

2. 队满与队空状态的区别解决

   - 在数组中始终留一个单元不用（**Front 所指的单元始终不用**）
   - 队列初始化：front == rear = 0
   - 队空条件：front == rear
   - 队满条件：（rear+1）% maxSize == front（**当队尾再加 1 追上队头时，队列满**）

3. Quene's ADT

```cpp
template<typename E>class Quene{
public:
    //清空队列
    virtual void clear() = 0;
    //入队
    virtual void enquene(const E&) = 0;
    //出队
    virtual E dequene() = 0;
    //返回队首元素的copy
    virtual const E& frontValue() const = 0;
    //返回当前队列长度
    virtual int length() = 0;
}
```

###### 作业题

7．针对带表头结点的单链表，试编写下列函数。  
(1) 定位函数 Locate：在单链表中寻找第 i 个结点。若找到，则函数返回第 i 个结点的地址；若找不到，则函数返回 NULL。

```cpp
template<typename E>
Link<E>* locate(Link<E> *head, int i) {
    if(i<=0) return NULL;
    int count = 0;
    Link<E>* p = head;
    while(p->next != NULL){
        p = p->next;
        if (++count == i) return p;
    }
    return NULL;
}

template <typename E>
Link<E>* locate(Link<E> *head, const int index)
{
	if (index <= 0) return NULL;
	int n = 0;
	Link<E>* curr = head;
	while (curr->next != NULL)
	{
		curr = curr->next;
		if (++n == index) return curr;
	}
	return NULL;
}
```

(2) 求最大值函数 max：通过一趟遍历在单链表中确定值最大的结点。

```cpp
template<typename E>
Link<E>* max(Link<E> *head) {
    Link<E>* temp = head->next;
    Link<E>* p = head->next;
    while(p->next != NULL){
        if (p->element > temp->element)
            temp = p;
        p = p->next;
    }
    return temp;
}

template <typename E>
Link<E>* max(Link<E> *head)
{
	Link<E> *curr = head->next, *temp = head->next;
	while (curr->next != NULL)
	{
		curr = curr->next;
		if (curr->element > temp->element) temp = curr;
	}
	return temp;
}
```

(3) 统计函数 number：统计单链表中具有给定值 x 的所有元素。

```cpp
template<typename E>
int number(Link<E> *head, const E& x) {
    int count = 0;
    Link<E>* p = head->next;
    while(p->next != NULL){
        if(p->element == x)
            count++;
        p = p->next;
    }
    return count;
}

template <typename E>
int number(Link<E> *head, const E& value)
{
	int num = 0;
	Link<E>* curr = head->next;
	while (curr->next != NULL)
	{
		curr = curr->next;
		if (curr->element == value) num++;
	}
	return num;
}
```

(4) 建立函数 create：根据一维数组 a[n]建立一个单链表，使单链表中各元素的次序与 a[n]中各元素的次序相同，要求该程序的时间复杂性为 O(n)。

```cpp
template<typename E>
Link<E>* create(E a[],int n) {
    if(n == 0) return NULL;
    Link<E> *head, *curr;
	head = curr = new Link<E>();

    for(int i=0; i<n; i++){
        curr->next = new Link<E>(a[i]);
		curr = curr->next;
    }
    return head;
}

template <typename E>
Link<E>* create(E *a, int n)
{
	if (n == 0) return NULL;
	Link<E> *head, *curr;
	head = curr = new Link<E>();
	for (int i = 0; i < n; i++)
	{
		curr->next = new Link<E>(a[i]);
		curr = curr->next;
	}
	return head;
}
```

(5) 整理函数 tidyup：在非递减有序的单链表中删除值相同的多余结点。

```cpp
template<typename E>
void tidyup(LLink<E>* list) {
    if(list == NULL) return -1;
    LLink<E>* p = list;
    list->moveToStart();

    for(int i=0; i<n; i++){
        list->insert(a[n]);
    }
    return list;
}

template <typename E>
void tidyup(Link<E> *head)
{
	Link<E> *curr = head->next;
	int temp = curr->element;
	while (curr->next != NULL)
	{
		if (curr->next->element == temp)
			curr->next = curr->next->next;
		else
		{
			curr = curr->next;
			temp = curr->element;
		}
	}
}
```

##### Chapter 5 二叉树 Binary Tree

###### 5.1 定义

1. 二叉树  
   二叉树（binary tree）是由结点（node）的**有限**集合组成，这个集合可以是**空（empty）**或者一个**根结点（root）**及两棵不相交的二叉树组成（**左边叫左子树（left subtree），右边叫右子树（right subtree）**）

2. 深度（depth）和高度（height）  
   **深度：结点 M 的深度就是从根到该结点的路径长度**  
   **高度：树的高度就是最深结点的深度+1**

3. 满二叉树（Full）和完全二叉树（complete）  
   **满二叉树：每一个结点要么是叶结点（没有 children）要么是有两个非空子结点的内部结点（两个 children）**，**_0 或两个子结点_**  
   **完全二叉树：除了最下面的一层，其他每一层都是满的，最下面一层的叶子结点都在左边**

4. 满二叉树定理  
   对于满二叉树来说，**叶子结点 = 内部结点+1**  
   推论：**树中的空指针 = 结点数+1**

5. 二叉树的性质

   - 在二叉树的第 i 层上至多有 2^(i-1)个结点
   - 深度为 k 的二叉树至多有 2^k-1 个结点
   - 对于任何一棵二叉树而言，叶子结点的数量是度为 2 的结点数量+1（特别地，满二叉树）
   - 具有 n 个结点的完全二叉树的深度为 log2 N +1

6. 完全二叉树的性质
   完全二叉树每一层结点数量最多是 2^i,i 为深度
   完全二叉树最多拥有 2^k-1 个结点，k 为高度

7. 二叉树结点的 ADT（**BinNode**）

```cpp
template <typename E> class BinNode{
public:
    //Base destructor 基本析构函数
    virtual ~BinNode(){};
    //return the node's value 返回结点的值（数据）
    virtual E& element() = 0;
    //set the node's value 给结点设置值（数据）
    virtual void setElement(const E&) = 0;
    //return the node's left children 返回结点的左孩子结点
    virtual BinNode* left()=0;
    //set the node's left children 给结点设置左孩子结点
    virtual setLeft(BinNode*) = 0;
    //return the node's right children 返回结点的右孩子结点
    virtual BinNode* right() = 0;
    //set the node's right children 给结点设置右孩子结点
    virtual setRight(BinNode*) = 0;
    //return true if the node is a leaf,false otherwise 结点是叶结点返回true，否则返回false
    virtual isLeaf()=0;

}
```

###### 5.2 二叉树的遍历（Traversal）

    按照一定的顺序访问二叉树的所有结点，叫做一次**遍历（Traversal）**， **什么时候访问根结点就是什么遍历**

1. 前序遍历（preorder traversal）  
   先访问**根结点**，再访问**左结点**，再访问**右结点**

2. 中序遍历（inorder traversal）  
   先访问**左结点**，再访问**根结点**，再访问**右结点**

3. 后序遍历（postorder traversal）  
   先访问**左结点**，再访问**右结点**，再访问**根结点**

4. 前序遍历的实现(递归法)

```cpp
template<typename E>
void preorder(BinNode<E>* root){
    if(root == null) return;
    visit(root);
    //先做合法性检查
    preorder(root->left());
    preorder(root->right());
}
```

    更换visit的位置就能实现前序、中序、后序遍历

5. 课本例子

- 计算一个二叉树中的结点数量

```cpp
template<typename E>
int count(BinNode<E>* root){
    if(root == null) return 0;
    //注意要有1哈哈哈
    return 1 + count(root->left()) + count(root->right());
}

```

- 计算一个树的的深度

```cpp
template<typename E>
int deep(BinNode<E>* root){
    if(root == null) return 0;
    //注意要有1哈哈哈
    return 1 +
        deep(root->left()) > deep(root->right()) ? deep(root->left()) : deep(root->right());
}

```

###### 5.3 二叉树的实现

1. 使用指针实现（Point）  
   对于每个结点：

   - 数据域
   - 左子树指针
   - 右子树指针

2. 表达式树可以使用 Union 实现

   ```cpp
   union{//枚举类型可挑选内部结点或者叶结点进行单一实现
       struct{//内部结点，操作符
           BinNode* left;
           BinNode* right;
           Operator opx;
       }intl;
       Oprand var;//叶结点，操作数
   }
   ```

3. 空间代价  
   **结构性开销：为了实现数据结构所花费的空间**  
   二叉树：P（指针域空间），D（数据域空间）。Overhead：2P/（2P+D）

4. 使用数组来实现完全二叉树  
   树的形状直接由数组的**下标**来确定
   ![pic5.3](https://pic.downk.cc/item/5f9815871cd1bbb86b2eac19.png)

###### 5.4 BST 二叉检索树(Binary Search Tree)

1. 定义  
   **_在二叉检索树中，每一个结点 K，它的左子树中所有的值都小于 K，右子树中所有的值都大于等于 K_**  
   特点：**中序遍历得到的序列，就是从小到大排序的序列**

2. BST ADT

```cpp
//二叉检索树（BST）的ADT
template <typename Key, typename E>
class BST : public Dictionary <Key, E>{
private:
	//二叉检索树的根
	BSTNode<Key, E>* root;
	//BST结点的总数
	int nodecount;

	//受保护的帮助函数
	void clearhelp(BSTNode<Key, E>*);
	BSTNode <Key, E>* inserthelp(BSTNode <Key, E>*, const Key&, const E&);
	BSTNode <Key, E>* deletemin(BSTNode <Key, E>*);
	BSTNode <Key, E>* removehelp(BSTNode <Key, E>*, const Key&);
	E findhelp(BSTNode <Key, E>*, const Key&) const;
	void printhelp(BSTNode <Key, E>*, int) const;

public:
	BST() { root = NULL; nodecount = 0; }//构造函数
	~BST() { clearhelp(root); }//析构函数

	//重新初始化这个BST
	virtual void clear() = 0;

	//插入一个记录在数里
	//k 需要插入的数据的键值
	//e 需要被插入的数据
	virtual void insert( const Key& k, const E& e) = 0;

	//从树中移除一个数据
	//k 要被移除的数据都键值
	//返回被移除的数据，如果那个位置为空的话返回NULL
	virtual E remove(const Key& k) = 0;

	//从字典的跟结点中移除并返回一个数据
	//返回被移除的数据， 如果树为空则返回NULL
	virtual E removeAny() = 0;

	//返回键值为k的数据，如果没有则返回NULL
	//k ：需要查找的数据的键值
	//返回一些匹配到k的数据
	//返回True如果这样的值存在的话，不存在则返回False
	//如果存在多个，返回其中随机的一个
	virtual E find(const Key& k) const = 0;

	//返回字典中记录的数量
	virtual int size() = 0;

	//打印这个BST
	virtual void print() const = 0;
}
```

3. BST 操作
   - 插入  
      把要插入的值与根结点做比较，如果比根结点小就找左子树，如果大于等于根结点就找右子树。递归调用即可实现。
   - 删除  
      删除的如果是一个叶结点，就直接删掉，如果是一个内部结点，那就要从右子树中找到一个最小值来补到这个位置上来

###### 5.5 堆和优先队列(Heap & Priority Queues)

1. 定义

   - 堆是一种完全二叉树
   - 最大堆（max heap）：任何一个结点的值都大于等于它的子结点的值（**因此跟结点是全堆的最大值**）
   - 最小堆（min heap）：任何一个结点的值都小于等于它的子结点的值（**因此跟结点是全堆的最小值**）

2. heap ADT

```cpp
template <typename E, typename Comp> class heap{
private:
	//堆数组的指针
	E* Heap;
	//堆的最大范围
	int maxsize;
	//堆中目前元素的数量
    int n;

	//把一个元素放到它合适位置的函数
	void siftdown(int pos){
		while (!isLeaf(pos)){//不是叶结点
			int j = leftchild(pos);
			int rc = rightchild(pos);

			if((rc < n) && Comp::prior(Heap[rc], Heap[j]))
				j = rc; //将j设置为更大的子元素值

			swap (Heap, pos, j);
			pos = j;

		}
	}
public:
	//构造函数
	heap(E* h, int num, int max)
		{ Heap = h; n = num; maxsize = max; buildHeap(); }

	//返回当前堆堆大小
	virtual int size() const = 0;

	//如果pos是叶子则返回True
	virtual bool isLeaf(int pos) const = 0;

	//返回当前位置的左孩子
	virtual int leftchild(int pos) const = 0;

	//返回当前位置的右孩子
	virtual int rifgtchild(int pos) const = 0;

	//返回父亲结点的位置
	virtual int parent(int pos) const = 0;

	//建堆
	virtual void buildheap() = 0;

	//插入item到堆里
	void insert(const E& item){
		Assert(n < maxsize, "Heap is full");
		int curr = n++;
		Heap[curr] = item; //开始只能把item放到堆的最后面

		//现在把它向上排，知道curr的父亲结点大于curr
		while( (cuur != 0) && (Comp:prior(heap[curr], Heap[parent(curr)] ) )){
			swap(Heap, curr, parent(curr));
			curr = parent(curr);
		}
	}

	//删除第一个元素, 并返回删掉的元素
	E removefirst(){
		Assert(n > 0, "Heap is empty");
        //先把它和最后一个元素交换，并且n-1，可以相当于删除元素（实际还在最后在着但我们一斤不管他来）
		swap(Heap, 0, --n);
        //然后对跟结点进行siftdown操作即可
		if(n != 0) siftdown(0);
        //返回最后一个元素（被删掉的元素）
		return Heap[n];
	}


	//删除特定位置的元素
	E remove (int pos){
		Assert((pos >= 0) && (pos < n), "Bad position");

		if(pos == (n-1) ) n--;//最后一个元素，没有什么可操作的
		else
		{
			swap(Heap, pos, --n);
			while((pos != 0) && (Comp:: prior(Heap[pos], Heap[parent(pos)])))
			{
				swap(Heap, pos, parent(pos));//把大的元素往上移动
				pos = parent(pos);
			}
			if( n != 0) siftdown(pos); //把小的元素下移
		}
		return Heap[n];
	}
};
```

3. heap constructor 堆构造器

   - constructor：直接使用无序数组到堆里，建立起完全二叉树
   - buildHeap：建堆，从后向前检查每一个内部结点，对其进行 siftdown
   - siftdown：在子树中调整 root，leftchild，rightchild 三者的大小，选出最大（小）的换到 root 上  
     构造过程：  
     **constructor -> buildHeap -> siftdown**

4. 堆的时间复杂度

   - 建堆 buildHeap：O(n)
   - 删除一个元素 remove：最差 O(log n)
   - 插入一个元素 insert：O(log n), 插入 n 个元素 O(nlog n)

5. **Priority Queues 优先队列**  
   一些按照重要性或优先级来组织的对象称为优先队列
   - **要求是要能快速释放最大值（如最高优先级）的对象**
   - **优先级可能会改变，要求要能重新排序这些任务（动态）**
   - Example：多任务操作系统的调度工作
   - Implementation：**Heap**

###### 5.6 huffman Coding Tree 哈夫曼编码树

1. 定长编码和变长编码

   - 定长编码：每个字符的编码大小都是固定的（比如都是 8bits），**如果每个字符的使用频率都相等，那么固定长度的编码是空间效率最好的方法**
   - 变长编码：每种字符的编码大小是不固定的，根据某种规则来规定其编码大小，比如哈夫曼编码。**根据字符使用频率来进行编码**

2. Definition 定义

   - **weight 权重**： 字符使用频率，对于哈夫曼树，叶结点才有权重
   - 叶结点**加权路径长度**：叶结点的权重乘以深度

3. huffman Tree Construction 哈夫曼树的构造-->贪心算法

   - 每次选取拥有最小权值的两个结点，将其结合
   - 结合以后要重新排序
   - 内部结点只有权值没有 value

4. huffman coding & decoding 哈夫曼编码和解码

   - 编码  
     哈夫曼树形成后，左路径都是 0，右路径都是 1。将编码后的对应表写出来
   - 解码
     直接使用原信息序列在哈夫曼树上走，每次走到一个跟结点就能解码出一个字符

5. 哈夫曼编码常考

   - 每个字母的期望代码长度  
      （每个字母出现的次数\*它的编码长度）/总的字母个数

6. huffman Node calss 哈夫曼结点类

```cpp
//哈夫曼树结点的类ADT
template <typename E> class HuffNode{
public:
	//基本析构函数
	virtual ~HuffNode (){}
	//返回权重
	virtual int weight() = 0;
	//判断是不是叶结点
	virtual bool isLeaf() = 0;
}

//哈夫曼树叶结点类实现
template <typename E>
class LeafNode : public HuffNode<E>{
private:
	//叶结点的值
	E item;
	//叶结点的权重
	int wht;
public:
	//构造函数
	virtual LeafNode (const E& val, int freq) = 0；
	//返回权重
	virtual int weight() = 0;
	//返回结点的值
	virtual E val() = 0;
	//判断是不是叶结点
	virtual bool isLeaf() = 0;
}

//内部结点子类实现
template <typename E>
class IntlNode : public HuffNode<E> {
private:
	//结点的左孩子
	HuffNode<E>* lc；
	//结点的右孩子
	HuffNode<E>* rc;
	//子树的权重
	int wgt;

public:
	//构造函数
	virtual IntlNode(HuffNode<E>* l, HuffNode<E>* r) = 0;
	//返回权重
	virtual int weight () = 0;
	//判断是不是叶结点
	virtual bool isleaf() = 0;

	//返回结点的左孩子
	virtual HuffNode<E>* left() const = 0;
	//设置结点的左孩子
	virtual void setLeft(HuffNode<E>* b) = 0;
	//返回结点的右孩子
	virtual HuffNode<E>* right() const = 0;
	//设置结点的右孩子
	virtual void setRight(HuffNode<E>* b) = 0;

}
```

6. Huffman Tree Impletation 哈夫曼树实现

```cpp
//哈夫曼树是由两个参数构成的
//类型被编码和一个比较器和两个同样的参数
template <typename E>
class huffTree{
private:
	//树的根
	HuffNode<E>* Root;
public:
	//树叶结点的构造函数
	virtual HuffTree(R& val, int freq) = 0;
	//内部结点的构造函数
	virtual HuffTree(HuffNode<E>* l, HuffNode<E>* r) = 0;
	//析构函数
	virtual ~HuffTree(){}
	//得到根结点
	virtual HuffNode<E>* root() = 0;
	//根结点的权重
	virtual int weught() = 0
}


//建造一个哈夫曼树 这是一个函数
//使用大顶堆来建造哈夫曼树，每次取出两个最小权重的结点，构造成树以后在把它插回去
template <typename E>
HuffTree<E>* buildHuff(HuffTree<E>** , TreeArray, int count){
	heap <HuffTree<E>*, minTreeComp>* forest= new heap<HuffTree<E>* , MinTreeComp> (TreeArray, count, count);
    //临时变量
	HuffTree<char> *temp1, *temp2, *temp3 = NULL;

	while(forest-> size() > 1){
		//把第一个结点放到树里
		temp1 = forest->removefirst();
		//off the list
		temp2 = foresr->removefirst();

		temp3 = new HuffTRee<E> (temp1, temp2);
		//把这个新的树返回到列表里
		forest->insert(temp3);
		delete temp1;
		delete temp2;
	}
	return temp3;
}
```

###### 第五章作业题

```cpp
void showTreeUsingLink(TreeNode<E>* root, int level=1){
    if(root == NULL) return 0;
    else{
        showTreeUsingLink(root->right(), level+1);
        cout << endl;
        for(int i=0; i< level-1; i++)
            cout << " ";
        cout << root->value();
        showTreeUsingLink(root->left(), level+1);
    }
}

int countLeaf(TreeNode<E>* root)//分治法统计叶子节点数目
{
    int count;
    if(root==NULL)
        count=0;
    else if(root->left()==NULL && root->right()==NULL)
        count=1;
    else
        count=countLeaf(root->left())+countLeaf(root->right());
    return count;
}

void change(TreeNode<E>* root){
    if (root->right() == NULL && root->left() == NULL){
        return;
    }
    TreeNode<E>* temp;
    temp = root->left();
    root->left() = root->right();
    root->right() = temp;

    if (root->left()){
        change (root->left());
    }
    if (root->right()){
        change (root->right());
    }
}

template<typename E>
void travelIteratively(BinNode<E>* root){
    Queque<BinNode<E>*> nodeQueue = new Queque<BinNode<E>*>();
    nodeQueue.push(root);
    while(!nodeQueue.empty()){
        root=nodeQueue.front();
        if(root!=null){
            cout<<root->value()<<" ";
            nodeQueue.push(root->left());
            nodeQueue.push(root->right());
        }
        nodeQueue.pop();
    }
}

bool isValidBST(BinNode<E>* root, int min, int max){
        if(root == NULL)
            return true;
        if (min < root->val && root->val < high)
            return (isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, high));
        else
            return false;
    }

template<typename E>
void isValidBST(BinNode<E>* TreeTop) {
    //用非递归中序遍历得到二叉树的序列
	stack<BinNode<E>*> STN;
    E A[100];
    int index=0;
	STN.push(TreeTop);
	while (STN.size()) {
		BinNode<E>* Top = STN.top();
		if (!Top.State) {
			a[index] = STN.pop()->element();
            index++;
			Top.State = 1;
			STN.push(Top);
			if (Top.rightNode) {
				a[index] = STN.pop()->element();
                index++;
				STN.push(*Top.rightNode);
				STN.push(Top);
			}
			if (Top.leftNode) {
				STN.push(*Top.leftNode);
			}
		}
		else {
			cout << Top.getName() << ends;
			a[index] = STN.pop()->element();
            index++;
		}
	}
    //BST应满足该序列为递增序列
    for(int i=0;i<index; i++)
        if(a[i]>a[i+1]) return false;
}
```

##### Chapter 6 树 General Tree

###### 6.1 定义

1. General Tree 通用树  
   不限制一个结点有几个子结点

2. 树结点的 ADT

```cpp
//树结点的ADT
template <typename E> class GTNode{
public:
	//返回结点的值
	E value();
	//判断是否是叶结点
	bool isLeaf();
	//返回父亲结点
	GTNode* parent();
	//返回坐左边的第一个孩子结点
	GTNode* leftmostChild();
	//返回右边的兄弟姐妹
	GTNode* rightSibling();
	//设置结点的值
	void setValue(E&);
	//插入第一个孩子
	void insertFirst(GTNode<E>*);
	//插入后面的兄弟姐妹
	void insertNext(GTNode<E>*);
	//移除第一个孩子
	void removefirst();
	//移除右边的兄弟姐妹
	void removeNext();
};


//一般树的ADT
template<typename E> class GenTree{
public:
	//清除所有结点并释放空间
	void clear();
	//返回树的根结点
	GTNode<E>* root();
	//联合两棵子树
	void newroot(E&, GTNode<E>*, GTNode<E>*);
	//画出一棵树
	void print();
};
```

3. 树的遍历  
   一般不使用树的中序遍历，只在乎前序和后序遍历（先根后根）。

4. 课本例子->使用**前序遍历**的遍历树

```cpp
template<typename E>
   void print(GTNode<E>* root){
       //如果目前的根是叶结点，那就输出Leaf，如果是内部结点那就输出Internal
       if(root->isLeaf()) cout << "Leaf:";
       else cout << "Internal:";
       //访问当前结点的值
       cout << root->value() << endl;
       //使用循环和递归来访问它的所有子结点
       for(GTNode<E>* temp = root->leftmostChild(); temp != NULL; temp = temp->rightSibling())
        print(temp);
   }
```

###### 6.2 父指针表示法

1. 定义  
   对树的每一个结点只保存一个指针域->**指向父结点**，这个指针叫做父指针，有利于**并查算法**
   - 并查算法：用一棵树代表一个集合

###### 6.3 树的实现

1. 子结点表表示法

   - 下标从 0 开始，0 为根结点
   - 第一列为当前结点的值 Val
   - 第二列为父结点的下标 Par
   - 第三列为指向孩子结点的指针域，链接下去的结点的链表 value 存子结点的下标
     ![pic6.1](https://pic.downk.cc/item/5fabaff41cd1bbb86bfda058.jpg)

2. 左子结点/右兄弟结点表示法

   - 下标从 0 开始，0 为根结点
   - 第一列为当前结点的左子结点的下标 Left
   - 第二列为当前结点的值 Val
   - 第三列为父结点的下标 Par
   - 第四列为右兄弟结点的下标
     ![pic6.2](https://pic.downk.cc/item/5fabb12b1cd1bbb86bfde1d7.jpg)

3. 动态结点表示表示法
   ![pic6.3](https://pic.downk.cc/item/5fabb1751cd1bbb86bfdf00e.jpg)
   ![pic6.4](https://pic.downk.cc/item/5fabb19d1cd1bbb86bfdf9e9.jpg)

###### 6.5 树的顺序实现方法

![pic6.5](https://pic.downk.cc/item/5fabb27c1cd1bbb86bfe22e4.jpg)

1. 用/代表 NULL 指针  
   **AB/D//CEG///FH//I//**  
   解析的时候遵循根->左->右的顺序，若一个结点满了则返回到上一层开始画

2. 内部结点使用（'）进行标记  
   **A’B’/DC’E’G/F’HI**

3. 对于一个通用树来说，可以用）来表示它是一个叶结点  
   **RAC)D)E))BF)))**

##### Chapter 7 内排序

###### 7.1 排序

1. 排序的时间开销  
   排序的时间开销可以用算法执行中的**数据比较次数 KCN 和数据移动次数 RMN 来衡量**

2. 静态排序和动态排序

   - 静态排序：  
      数据本身就是待排序的东西，**排序过程就是对数据对象本身进行物理的重排**
   - 动态排序：  
      不需要对数据本身进行物理移动，只用对**指向这个物理对象的指针进行排序**即可

3. 内排序和外排序
   - 内排序  
      整个排序过程不需要访问外存，**全部在内存中完成**
   - 外排序  
      **序列庞大，不能完全载入内存**

###### 7.2 三种时间代价为 O(n^2)的排序

1. 插入排序

- 每次从 i 的位置往前，依次检查每两个元素是否符合排序条件，不符合就交换
- code

  ```cpp
  template <class Elem, class Comp>
   void inssort(Elem A[], int n) {
   for (int i=1; i<n; i++)
       for (int j=i; (j>0) &&
               (Comp::lt(A[j], A[j-1])); j--)
       swap(A, j, j-1);
   }

  ```

2. 冒泡排序

- 每 i 趟从后面的 n-i 个数据中推一个最大值（或最小值）上来  
   从最后一个开始对比，若不满足排序条件就交换  
   **优化：若在一趟里没有发生过交换，就说明序列已经有序**

- code
  ```cpp
  template <class Elem, class Comp>
  void bubsort(Elem A[], int n) {
  for (int i=0; i<n-1; i++)
      for (int j=n-1; j>i; j--)
      if (Comp::lt(A[j], A[j-1]))
          swap(A, j, j-1);
  }
  ```

3. 选择排序

- 每次从后面的 n-i 个里找到一个最小值，用一个 index 记录它，每一趟完成以后 将其与第一个元素交换  
   **不稳定**:在排序完成后，原本相等的两个数可能会交换位置
- code

  ```cpp
  template<typename E, typename Comp>
  void selsort(E A[], int n){
      for(int i=0; i<n; i++){
          int index=i;
          for(int j=n-1; j>i;j++){
              if(a[j] < a[index])
               index = j;
          }
          swap(a, i, index)
      }
  }
  ```

4. 时间代价问题  
   这三种排序算法的时间代价比较拉垮  
    ![pic7.1](https://pic.downk.cc/item/5fb374ceb18d62711304e6b1.jpg)
   交换相邻记录成为一次交换（exchange），因此这三种有时候又叫做交换排序

###### 7.3 shell 排序

1. 定义  
   也叫**缩小增量排序**， 基本思想是对排序序列先做宏观调整，再做围观调整

2. 操作  
   将所有的 n 个记录分成 d 个子序列（d 组），**d 就是增量， 他的大小会在排序过成中逐渐减小，直到最后一次他会变成 1**  
   在每一趟的排序里，就是一次简单的插入排序

3. shell 排序的实现

```cpp
//一趟实际上就只是一个简单的插入排序
template<typename E, typename Comp>
void inssort2(E A[], int n, int incr){
    for(int i=incr; i<n; i++)
        for (int j=i; (j>=incr) &&
               (Comp::lt(A[j], A[j-incr])); j-=incr)
       swap(A, j, j-incr);

}
//shell排序的实际就是分成一些小的插入排序
template<typename E, typename Comp>
void shellsort(E A[], int n){
    for(int i=n/2; i>2; i/=2)
        for(int j=0; j<i; j++)
            inssort2<E, Comp>(&A[j], n-j, i);
    inssort2<E, Comp>(A, n, i);
}
```

4. 算法分析  
   希尔排序的时间复杂度并没有得到严格证明，在实际运行上得到但时间复杂度是 O(n^1.5)

###### 7.4 归并排序

1. 操作  
   先递归将所有的子序列二等分，知道每个子列只有一个元素，开始归并  
   归并：分别一次比较两个子序列未处理的第一个元素，选出最大的（或最小的）放到新的两倍大的序列里，知道一个序列空了以后，将另一个序列全部导入

2. 标准归并算法

```cpp
template <class Elem, class Comp>
void mergesort(Elem A[], Elem temp[], int left, int right) {
  int mid = (left+right)/2;
  if (left == right) return;
  mergesort<Elem,Comp>(A, temp, left, mid);
  mergesort<Elem,Comp>(A, temp, mid+1, right);
  for (int i=left; i<=right; i++) // Copy
    temp[i] = A[i];
  int i1 = left; int i2 = mid + 1;
  for (int curr=left; curr<=right; curr++) {
    if (i1 == mid+1)      // Left exhausted
      A[curr] = temp[i2++];
    else if (i2 > right)  // Right exhausted
      A[curr] = temp[i1++];
    else if (Comp::lt(temp[i1], temp[i2]))
      A[curr] = temp[i1++];
    else A[curr] = temp[i2++];
}}

```

3. 算法分析
   - 时间复杂度：O(nlogn)
   - 空间复杂度：O(n),因为需要一个和元素组等大的辅助数组

###### 7.5 Quick 快速排序

1. 操作  
   寻找一个**枢轴 pivot**， 比他小的移动到他左边，比他大的移动到它右边，之后在左右两部分中再次使用这个方法（递归）

2. 实现->每一趟

   - 在序列的首部和尾部分别设置一个指针
   - 开一个空间存储枢轴
   - 每一次只有一个指针会走，比如一开始设定左指针为枢轴，那么在右指针指向一个小于枢轴的值的时候，将它覆盖到左指针上，接着左指针开始走，走到大于枢轴的值的时候覆盖到右指针上，然后右指针走，如此循环往复
   - 当两个指针相遇的时候，将枢轴放到这里来，因此序列分成两部分，再进行递归调用

3. code

```cpp
template<typename E, typename Comp>
void qsort(E A[], int i, int j){
    //当序列只有一个或0个元素的时候，就停止递归
    if(j<=i) return ;
    //使用函数findpivot去找一个枢轴
    int pivotindex = findpivot(A, i, j);
    //把枢轴放到序列的最后，用来存枢轴
    swap(A, pivotindex, j);

    //patition函数的返回值k就是最终两个指针停留的地方，
    //也就是那一趟中，最后枢轴应该停留的地方
    int k = patition<E, Comp>(A, i-1, j, A[j]);
    //把枢轴放过来
    swap(A, k, j);
    //对形成的两个子列再递归调用qsort函数
    //直到序列有0或1个元素就停下来
    qsort<E, Comp>(A, i, k-1);
    qsort<E, Comp>(A, k+1, j);

}
```

4. 算法分析  
   平均情况的时间复杂度 O(nlog n),是目前的排序算法中在平均情况下最好的一种排序

###### 7.6 堆排序

1. 定义  
   堆排序是一种基于树的排序算法，使用数组实现的堆，**它的数组实现方式对空间的利用率也很高**，对于**建堆函数时间复杂度为 O(n)，取堆顶值的时间复杂度为 O(logn)，因此堆排序的最佳、平均、最差情况的执行时间都是 O(nlogn)。**

   > 大顶堆->形成从小到大递增序列  
   > 小顶堆->形成从大到小递减序列

2. code

```cpp
template <class E, class Comp>
void heapsort(E A[], int n) { // Heapsort
  E mval;
  maxheap<E,Comp> H(A, n, n); //建堆
  for (int i=0; i<n; i++)
    mval = H.removefirst();  // Every time put max/min at end， 形成序列
}
```

###### 7.7 分配排序和基数排序

1. 分配排序思想  
   直接使用记录的关键码（key 值）作为作为另一个承载数组的下标，放到该下标里面去。

   ```cpp
       for(int i=0; i<n; i++)
        B[A[i]] = A[i];
   ```

   - **允许关键码重复->使用链表数组，这样每个数组元素就成为一个盒子**
   - 该思想包含记录的分配和回收，**在回收时的时间复杂度就会受到原纪录值的大小的影响**
   - 桶排序和基数排序是对分配排序的进一步扩展

2. 桶排序（bucket sort）  
   **每个盒子可以和多个关键码值相关**，因此这时候盒子又叫桶。  
   目的是用代价较小的**分桶技术**和较快的**收尾排序（cleanup sort）**来进行排序

3. 基数排序（Radix sort）  
   一个基于数组的基数排序算法：  
   ![pic7.7](https://pic.downk.cc/item/5fb8725eb18d627113349de0.jpg)
   code
   ```cpp
   /**
   * @param A[] 原始数组
   * @param B[] 辅助数组
   * @param cnt[] 姑且称之为桶数组
   */
   template <class Elem, class Comp>
   void radix(Elem A[], Elem B[],
           int n, int k, int r, int cnt[]) {
   // cnt[i] stores # of records in bin[i]
   int j;
   for (int i=0, rtok=1; i<k; i++, rtok*=r) {
       for (j=0; j<r; j++) cnt[j] = 0;
       // Count # of records for each bin 每一次统计元素的从低到高的每个位，将其放到cnt桶数组里
       //实际上就是分配操作
       for(j=0; j<n; j++) cnt[(A[j]/rtok)%r]++;
       // cnt[j] will be last slot of bin j. 将桶数组进行累加计算，因而得出的是第j个盒子最后一个下标
       for (j=1; j<r; j++)
           cnt[j] = cnt[j-1] + cnt[j];
       //然后在B这个辅助数组里就按照桶的规则来放 从后往前放，在一个桶放完以后它的位-1，代表桶中下一个相同元素来的时候应该放的位置
       //实际上就是回收操作
       for (j=n-1; j>=0; j--)\
           B[--cnt[(A[j]/rtok)%r]] = A[j];
       //copy B back to A
       for (j=0; j<n; j++) A[j] = B[j];
   }}
   ```
   **_时间代价：O(nlogn)_**

###### 7.8 排序算法的实验比较

![pic7.8](https://pic.downk.cc/item/5fb87bf3b18d62711336ea08.jpg)

###### 7.9 排序算法的稳定性

1. 稳定  
   稳定排序是指**原来相等的两个元素前后相对位置在排序后依然不变。**

2. 为什么要对排序算法提出稳定性的要求？  
   抽象来说就是，有两个排序关键字的时候（而且往往需要不止一次的排序），**稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数。不会改变基于其他关键字时的相对顺序关系**

3. 各种算法的稳定性  
   | 排序算法 | 稳定性 |
   | --- | --- |
   | 冒泡排序 | 稳定 |
   | **选择排序** | **不稳定** |
   | 插入排序 | 稳定 |
   |**希尔排序** | **不稳定** |
   |归并排序| 稳定|
   |**快速排序**| **不稳定**|
   |**堆排序**|**不稳定**|
   |基数排序|稳定|
   |**桶排序**|**不稳定**|

##### Chapter 8 FM & External Sort 文件管理和外排序

###### 8.1 主存和辅存

1. 数据结构和文件结构

   - **数据结构**是数据在**内存（main memory RAM）**上的存储结构
   - **文件结构**是数据在**辅存（secondary memory）**上的存储结构

2. 内存和辅存

   - 内存：**_RAM_**易失（**volatile**）在关闭电源以后回失去数据存储
   - 辅存：硬盘、磁盘、光盘，具有永久储存的能力，代价是访问时间更长

3. 磁盘设计原则  
   **使磁盘的访问次数最少**，因为从磁盘读取数据是一个 IO 操作，花费大量时间

   - 方法 1:合适安排信息的位置，以最少的当问次数就能得到所需要的数据。  
      **文件结构（file structrue）：对于在辅助存储器中的数据，其数据结构就成为文件结构，文件结构的组织应当使磁盘访问次数最少**

   - 方法 2:使用缓冲技术  
      通过少量的额外开销预测未来将要被使用的数据，在一次 IO 中也加载到内存  
      **缓存技术：保存之前的访问信息，从而减少当年的访问需要**

###### 8.2 磁盘

1. 逻辑文件和物理文件

   - 逻辑文件（logic file）：程序员把存储在磁盘中可以随机访问的文件看成一段连续的字节，**而且可以把这些字节结合起来构成记录，这叫逻辑文件**
   - 物理文件（physical file）：通常不是一段连续的字节，**而是成块分布在整个磁盘中**

2. 文件管理器（file manager）  
   是操作系统的一部分，当进行文件请求时，实现**应用程序请求从逻辑文件中读取数据时，它把逻辑位置映射为磁盘的具体位置**

3. 磁盘结构

   - 盘片 Platter
   - 主轴 spindle
   - 读写头 read/write head（IO head）
   - **扇区 sector：IO 的基本单位**
   - 磁道 track：盘片上的一个同心圆环
   - 扇区间间隙：intersector gap：磁头通过间隙来识别扇区的结束
   - **交错因子 interleaving factor：**  
     **在一个磁道上，逻辑上相邻的两个扇区的物理实际距离**
   - **簇 cluster**  
     **多个扇区的组，是文件分配的基本单位，由文件管理器的文件分配表（File Allocation Table）来记录每个文件是由那些簇组成的**
   - **引用局部性**  
      当在磁盘上的记录被读时，下一个请求很有可能是来自这个文件中的附近的位置
   - 内部碎片（internal fragmentation）  
      一些没有被使用然而不会被用到的剩余空间

4. 磁盘访问代价
   - **寻道时间（seek time）**：磁头找到相应磁道的时间，**是磁盘 IO 的主要代价**
   - **旋转延迟（rotation delay or latency）**：**取平均旋转延迟为磁盘转半圈的时间**，for7200rpm， this is 8.3/2=4.2ms
   - 数据传输时间：实际传输读写数据的时间

###### 8.3 缓冲区和缓冲池（Buffer）

1. 缓冲区  
   在一次读取的时候通常会将整个扇区的内容都读取到内存中  
   通常会使用一个缓冲区用于输入，另一个用于输出  
   **双缓冲机制（double buffering）：在 CPU 将数据写入输出缓冲时，可以将另一个输出缓冲的数据写入磁盘，输入缓冲也是同理。因此双缓冲机制需要至少四个缓冲区**

2. 缓冲池  
   一系列的缓冲区组成的缓冲池
3. 置换策略
   - FIFO 先进先出
   - LFU 最不频繁使用法
   - LRU 最近最少使用法（通常）

###### 8.5 外排序

1. 定义  
   数据太大了内存装不下，要排序它，必须把一部分取到内存，处理，再写回去。**外排序必须最小化磁盘访问**  
   通常情况下，记录的大小比关键码大得多，**所以一般使用关键码和指针的的组合来进行排序，这个指针指向的就是远记录在 disk 中的位置**

   - 把文件分成尽量大的初始**顺串（一组已经排好序的记录）**
   - 把所有顺串归并到一起，形成一个已排序的文件

2. **置换选择排序 -> 创建顺串**  
   是堆排序的一种变体，可以为**M 大小的 RAM 创建 2M 大小的顺串（由扫雪机模型分析得出）**
   ![pic8.5](https://pic.downk.cc/item/5fb8f4b1b18d62711356e8cc.jpg)
   后面从缓冲区中取到的值要是小于跟结点，则把它放到堆的最后，作为下一个顺串来输出。

3. **多路归并 -> 将顺串归并形成已排序文件**  
   置换选择算法使用的堆空间一般会是好几个块的大小，而二路归并每次只用一个块的记录在主存中，因此那个堆空间大小的主存并没有得到有效利用。  
   **使用多路归并可以提升主存利用率，同时还可以大大减少归并顺串所需要的扫描趟数。**
   假设堆空间为 B，那顺串大小就是 2B，所以一次 B 路归并就可以处理 2B^2 大小的文件，这个增长速度是很快的，所以采用置换选择排序+多路归并来解决外排序问题是很有效率的

4. 外排序算法优秀原则
   - 建立尽量大的初始顺串
   - 在所有阶段尽可能使输入处理输出**并行**（包括双缓冲机制的使用和尽量大的 N 路归并）
   - 使用尽量多的工作主存，因为外排序的主要限制还是在于 IO
   - 如果可能，使用多块磁盘，使 IO 也具有更大的并行性

##### Chapter 9 Searching 检索

###### 9.0 检索的概念

1. 检索  
   **精确匹配查询（exat-match query）：在一组记录中找到具有某个关键码值的记录**  
   **范围查询（range query）：或者找到关键码值符合某些条件，或在某些范围内的一组记录**

2. 检索的三种实现

   - 顺序表和线性方法
   - **根据关键码值直接访问方法（散列方法）**
   - **树索引方法**

###### 9.1 顺序表和线性方法

对于已排序的数组（比如递增排序）

1. 跳跃检索（jump search）  
   从头开始，每次跳过 j 个空间进行检索，如果某 A[nj]比 data 小了，那么就在 A[(n-1)j]和 A[nj]之间只用线性查找。  
   是分治法（divide and conquer）的一种
2. 二分查找
   每次比较现在所在区间的 mid 值，然后根据 mid 值的大小来更换查找区间

###### 9.2 自组织线性表

1. 82 原则  
   80%的访问都针对于 20%的记录。

2. 自组织的线性表  
   **会根据在链表中记录的访问来修改记录的位序**，三种传统启发式规则

   - count 计数方法：链表按照访问次数来排序（类似 LFU）
   - **Move-to-Front：元素如果被访问就会被放到链表最开头去（类似 LRU）**
   - Transpose 转置方法：元素如果被访问，就会和前一个元素交换位置

3. 文本压缩（text compress）  
   **使用 Move-to-Front 方法**：
   - 如果单词在前面出现过，就传送这个单词现在在线性表中的位置，并把这个单词拿到最前面去
   - 如果没有出现过，就传送这个单词，并把它加到线性表的最前面去。

###### 9.4 Hashing 散列方法

1. 概念  
   可以通过一些计算，把**关键码值直接映射到数组中的位置来访问记录**，这个过程就叫**散列（Hashing）**  
   **映射叫做哈希函数（hashing），存放记录的数组叫哈希表（Hash Table），表的一个位置叫做槽（slot）**  
   ASL：Average Search Length 平均检索长度

   - 适用于集合 set（关键码不重复）
   - 不适用于范围检索

2. **冲突（collision）**  
   **如果两个具有不同关键码值的记录拥有相同的哈希值（在表中的同一个槽里），那么就说这两个记录有冲突**

3. 构建哈希表和检索过程

   - 使用关键码值进行散列，得到哈希值（位置）
   - 这个位置已经被占用（构建时）比较当前位置的关键码值是否和待查找相同（查找时），使用相同的**冲突解决策略**（collision resolution policy）

4. **散列函数（Hashing Function）**  
    一般来说，希望选择的哈希函数把记录以相同概率分布到哈希表的槽中  
    因此哈希函数的效果，依赖于关键码值在允许的关键码范围内的分布  
    所以要依据情况来选择散列函数，目标是使冲突尽可能的小

   - 数字分析法：分析关键码，取其分布均匀的几位作为地址，适用于能预先估计出关键字的每一位出现各种数字的频度
   - 平方取中法：能扩大差别，只用于关键码每一位的某些数字出现频度都很高的情况
   - 折叠法：将关键字分割，取他们的叠加和作为地址，适用于关键码数字位数很多
   - 直接定制法：地址是关键字的线性函数，适用于地址集==关键码集
   - 取余法：关键码对 P 取余，P 应为不大于 M（表长）的素数或不含 20 以下的质因子
   - 随机数法：使用一个伪随机函数，伪（不是真随机，至少关键码相同每一次使用该函数都能得到相同的地址）

   对于字符集的关键码值：

   - 霍纳算法：计算字符集的 ASCII 码值，并且在每一次相加时乘以一个常数

   ```javascript
   function honer(string, arr) {
     const H = 37; //建议使用一个较小的素数
     var total = 0;
     for (var i = 0; i < string.length; i++) {
       total += H * total + string.charCodeAt(i);
     }
     total = total % arr.length;
     return total;
   }
   ```

5. **闭散列方法(Closed-Hashing)**  
    把冲突的记录存在表中的另一个槽中，静态，数组

   - 桶式散列  
     把 M 个槽分成 B 个桶，其实散列函数是以 B 为模，如果桶没满就放到桶里，如果桶满了就放到一个叫做溢出桶的桶里

   - **开放定址法**  
      开放所有槽的地址，一个地址可以放由哈希函数得到的不属于改地址的的关键码  
      冲突发生时，使用**线性探查**的方式去找一个可以放的地址，意思就是往后或前找第 d 个位置去放
     - 基本聚集：关键码探查序列的某些段重叠在一起
     - 二级聚集：两个记录散列得到的基槽是同一个，因为探查函数是关于基槽的函数，因此这种聚集只能使用双散列方法
       线性探查的几种产生 d 增量的方式：

   1. 线性探测再散列  
      d = c\*i（最简单的情况 c=1）
   2. 平方探测再散列  
      d = 1^2，-1^2, 2^2, -2^2 ......
   3. 随机探测再散列  
      d 是一组伪随机数列
   4. 双散列探测散列  
      d = i \* Hash(Key)

   - 负载因子(load factor)  
     å = N/M （N 是表中当前记录数，M 为表长）

6. **开散列方法(Open-Hashing)**  
   把记录存储在表外，动态，链表

   - 开散列方法最简单的实现方式就是**把哈希表的槽定义为一个链表的表头，所有哈希值相同的记录都链接在后面**

7. 删除  
   为了**不影响以后的检索**（如果简单删除一个槽里的记录可能会对以后的检索产生印象，比如使用过冲突解决策略的，就会在这个位置停止查找）
   从哈希表中删除元素时，使用一个特殊标记标记这个槽 -> **墓碑(tombstone)**：用来表示曾经有一条记录占用过这个槽，但是现在不再使用了。  
   但是墓碑会增加 ASL(平均查找长度)，解决办法：
   - 在删除时进行局部重组，试图缩小 ASL：把探查序列后面的记录交换到当前删除记录的槽中
   - 定期重新散列整个表

##### Chapter 10 indexing 索引

###### 10.0 索引技术

1. 索引技术支持

   - 高效率的**插入删除操作**
   - 检索操作：**精确匹配查询、范围查询、最大值/最小值查询**

2. 文件处理术语：
   - 顺序输入文件(entry-sequenced file):**按照记录进入系统的顺序存储在磁盘中**  
      相当于一个未排序的线性表，因此不支持高效率检索
   - 索引(indexing):**把一个关键码与他对应的数据记录的位置相关联的过程**
   - 索引文件(index file):**关键码和指针关联，指针用来指向主数据库文件中的完整记录**
   - 主码(primary key):**数据库中每一条记录的唯一标识**
