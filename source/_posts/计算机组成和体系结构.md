title: 计算机组成和体系结构
author: Micah
date: 2020-09-09 18:50:29
tags:

---

#### 课程介绍

- 继续刷分

#### 课程考核

- 40% 平时成绩（练习 30 分，考勤 10 分）
- 10% 半期
- 50% 期末成绩

#### content

##### Chapter 1 引言

1. overview  
   两部分：**计算机组成**和**计算机体系结构**

   - 计算机组成：控制信号、信息传递方式、存储器类型
   - 计算机体系结构：指令格式和指令集、操作码、数据类型、寄存器、寻址方式、主存储器的访问方式和 IO 机制

2. **_硬件和软件等效原理_**：任何可以利用软件实现的事情都可以用硬件来实现。反之，任何可以用硬件来实现的事情也可以用软件来实现。  
   区别在于：

   - 硬件的执行速度会比软件快
   - 软件实现会具有更高的灵活性

3. 计算机的三个最基本的组成部分

   - 用来解释和执行程序的处理器
   - 用来存储数据和程序的存储器
   - 输入输出机制（IO）

4. 计算机发展史

   - . 第零代：机械计算器

   1. 第一代：真空管计算机  
      真空管(vacuum tube)：可以控制电子系统中的电子流动。
   2. 第二代：晶体管计算机  
      晶体管(transistor)：用固体器件制造的真空三极管  
      晶体管比真空管体积更小，功耗更低，而且工作性能更加可靠。
   3. 第三代：集成电路计算机
   4. 第四代：超大规模集成电路计算机

5. 计算机的分层组织结构

   - 第 6 层：用户层
   - 第 5 层：高级语言层
   - 第 4 层：汇编语言层
   - 第 3 层：系统软件层，主要处理操作系统指令
   - 第 2 层：指令集体系结构层（机器层），它是由特殊的计算机系统结构所能识别的机器语言组成。
   - 第 1 层：控制层，在这个层次上，控制单元将确保正确的译码并执行指令，并且正确的将数据传送到正确的位置。  
      控制单元：

     1. 硬连接（hardwired）：用导线直接连接。
     2. 微编程（microprogramming）：微程序控制

   - 第 0 层：数字逻辑层

6. 冯·诺依曼模型  
   储存程序的计算机体系结构的基本特征：
   1. 三大硬件系统：
      - 中央处理器（CPU）包括一个控制单元，一个算数逻辑单元（ALU） 若干个寄存器 程序计数器
      - 主储存器系统(main memory)
      - 输入输出系统（IO system）
   2. 工作原理：
      **取指-译码-执行（fetch-decode-excute cycle）周期**

##### Chapter 2 计算机系统中数据的表示

###### 2.1 Introduction

1. 计算机中信息的最基本单元是位（bit）。

2. 计算机中**可寻址的最小单位**是字节（byte）。

3. 计算机字节的连续组织是一个字（word）。  
   **在不同的计算机中一个 word 的大小是不同的**  
   要按数据线的宽度来决定

###### 2.5 浮点数的编码 Float-Point Representation

1. 计算机中使用科学计数法来表示浮点数  
   由三个部分组成：  
   （IEEE—754 单精度浮点数 Float）32bit

   - 符号位 Sign（1 bit）
   - 指数位 Exponent（8 bit）
   - 尾数 Significand（23 bit）

   （IEEE-754 双精度浮点数 Double）64bit

   - 符号位 Sign（1 bit）
   - 指数位 Exponent（11 bit）
   - 尾数 Significand（52 bit）

   课程使用 1 5 8 来表述浮点数

2. 具体计算

   - 符号位  
     正数 0，负数 1

   - 指数位  
     将小数变成 0.XXXX 格式以后，将指数取出+2^(指数位-1)  
     这样做的目的是实现负指数的偏移

   - 尾数（有效数）  
      在本课程中，需要将小数变为 0.XXXX 格式，然后小数点后面的 XXXX 就是有效数。
     IEEE-754 中是变成 1.XXXXXXX 格式，然后存储小数点后面的 XXXXXX，这样做有利于节约空间

3. 加减  
   实现浮点数加减时要将指数位对其！！  
   基于这一原则， 在对齐时如果两个数相差较大，则会造成数据溢出与结果不准确

###### 2.7 用于数据记录和传输的编码方式

1. 异步数据传输  
   使用一个高电平和一个低电平代表数据传输的开始，然后开始传输数据，最后以一个高电平结尾。
2. 同步数据传输  
   在传输数据的同时传输一个时钟，用于 cpu 和内存之间的传输，cpu 内部收到数据之后 把数据和时钟结合得到数据

###### 2.8 错误检测与校正

1. CRC 循环冗余编码校验  
    摩尔除法：一样是 0，不一样是 1。  
    除数是双方约定好的一个二进制数（一般是 4 位）  
    最后可以得到一个余数，**_余数的位数是除数位数-1。_**

   在 CRC 编码中，除数为要传输的的数据序列。

> - 首先在信息位（数据序列）的末尾加上余数的位数的 0
> - 用约定的一个除数去除这个数据序列
> - 最后得到的余数，放在原本信息位的最后（替代那些 0）

这样得到的序列就能够被约定的除数来整除，如果接收方不能被整除，那么就存在数据的传输错误

2. 海明编码（Hamming Code）  
   海明编码采用的是奇偶校验的概念，可以对已经错误的编码进行校正

3. 海明编码具体操作

> 1. 利用公式（m+r+1）<= 2^r，m 是编码对象（信息码）的位数，r 就是插入的校验码的个数。
> 2. 编码字的长度就是 m+r，把它从右到左进行编码，从 1 开始。2 的幂次方的位置为校验位，校验位 P0P1P2P3 这样编。其他位置是信息位。
> 3. 将 M+R 个总码进行 2^n 这样的表示，比如 7=1+2+4，8=8，9=1+8
> 4. 最后将校验码写出，比如 p0 校验码就是要含有 1 的所有位码的逻辑与运算。奇（odd）校验就是 1 的个数为奇数，偶（even）校验就是 1 的个数为偶数。

4. 海明编码检测错误的方法
   - 分别去检验所有校验位的正确性：将所有检验位重新加一遍，要是由错误表示信息码中存在错误。
   - 0 表示没有错误，1 表示有错误。将有 1 的结果以 2 为底，位码为幂，运算以后加起来就是发生错误的位置。

##### Chapter 4 MARIE:简单计算机模型

###### 4.1 Introduction

1. CPU 的基本知识和组成原理  
   中央处理器（Center Processing Unit）的任务：**_负责提取程序指令，并对指令进行译码，然后按程序规定的顺序对正确的数据执行各种操作（取指-译码-执行）_**

   - 数据通道（datapath）：**_寄存器（Register）+ 算术逻辑单元（ALU）_**
   - 控制单元（control unit）：**_负责对各种操作进行排序并保证各种正确对数据适时得出现在所需的地方_**

   1. 寄存器（Register）：是一种存储二进制数据的硬件设备，用于存储各种数据。  
      **寄存器可以存储数据、地址、或控制信息。**

   2. 算术逻辑单元（ALU）：执行算术运算和逻辑运算。  
      一般 ALU 需要一个或两个输入和一个数据的输出，ALU 的操作经常会影响状态寄存器（status register）

   3. 控制单元（control unit）
      比如**程序计数器 PC（Programing Counter）：存放下一条要执行的指令的位置**。  
       **状态寄存器（Status Register）：存放某些特殊的操作状态**：溢出、进位、借位等

2. 总线（bus）  
   概念：**是一组导线的组合，他作为一个共享和公用的数据通道将系统的各个子系统链接在一起。**

   总线按目的划分：

   - 数据总线（data bus）：**传递的是必须在是计算机的不同位置之间移动的实际信息。**
   - 控制总线（control bus）：**指示哪个设备允许使用总线，以及使用总线的目的**（比如读 or 写）
   - 地址总线（address bus）：**指示数据读写的位置**
   - 电源线（power line）：供电

   信息的传递都发生在一个**总线周期（bus cycle）**里：完成信息传递的时钟个数。

   总线按*物理结构*划分：

   - 同步总线（synchronous bus）：由**时钟**控制，每个事件只有在时钟脉冲到来时才会发生，**事件发生的顺序由时钟脉冲来控制**
   - 异步总线（asynchronous bus）：使用一种复杂的握手协议（handshaking protoclo）来**强制实现与计算机其他操作的同步**

   总线仲裁（bus arbitration）：为某些主控设备设定优先级别，且保证每个设备都有机会使用总线。

3. 时钟（clock）  
   **时钟信号用来同步计算机内部操作**

4. 输入输出系统（I/O system）  
   概念：指外围的各种设备**外设（device）和主存储器（main memory）之间的数据交换**  
   IO 设备并不会直接和 CPU 连接，而是采用**接口（interface）**的方式来处理数据交换

5. 存储器组成和寻址方式  
   一般将存储器宽度设置为机器字（word）的大小。

   1. 编址方式：

   - 按字节编址（byte-address）：**每个字节**都有自己唯一的地址  
     如果一个字有多个字节，那么**字的地址是最低地址的字节的地址**
   - 按字编址（word-address）：每个字（word）都有自己的唯一地址，不流行

   2. 内存表示（RAM）  
      **内存通常用 L x M（长度 x 宽度）来表示**，比如 4Mx16：表示为长度有 4M 长和 16 的位宽，**乘起来就是内存的容量**。并且把 4M 表示为 2 的幂次方后这个**幂 N 就是编址宽度（需要用 N 位的二进制数来对每个字节进行编址）**

   3. 存储器交叉存储技术

   - 高位交叉存储（high-order interleaving）：**使用地址的高位来选择存储器组**  
     这样就可以直接将地址分配给含有连续地址的存储器模块
   - 低位交叉存储（low-order interleaving）：使用地址的低位来选择存储器组  
     会造成连续的存储器地址被分配到不同的存储器模块中

6. 中断（Interrupt）  
   概念：中断就是**改变（或中断）系统正常执行流程的各种事件**， 是异常（exception）的一种  
   触发中断的原因：

   - I/O 请求 （**正常中断**）
   - 出现算术错误
   - 算数溢出
   - 硬件故障
   - 用户定义的中断点
   - 页面错误（page fault）
   - 非法指令
   - 其他原因

   中断分为**可屏蔽中断（可以被禁止或忽略）**和**不可屏蔽中断（高优先级的中断，不能被禁止，必须相应）**  
   中断发生后，执行 ISR（Interrupt Serve Routine）**中断服务程序**

###### 4.2 MARIE

1. 体系结构（MARIE 的特点）

   > - 使用二进制数和补码表示法
   > - 存储程序和采用字长度
   > - **_按字（word）编址_**
   > - 主存为 4K，（意思是**地址为 12bit**）
   > - **数据为 16bit**
   > - **指令是 16bit（操作码 4bit + 操作数地址 12bit）**

2. 寄存器和总线  
   寄存器：（**存数据和指令是 16bit，存地址是 12bit**）

   > - AC(accumulator 累加器)：16bit，用来存储数据，是一个通用寄存器
   > - MAR（memory address register 存储器地址寄存器）：12bit，用来存被引用数据的存储器地址
   > - MBR（memory buffer register 存储器缓冲寄存器）：16bit，用来存刚从存储器中读取或者将要写入存储器的数据
   > - PC（program counter 程序计数器）：12bit，用来存下一条指令的地址
   > - IR（Instruction register 指令寄存器）：16bit，用来存将要执行的指令
   > - InREG（Input register 输入寄存器）：8bit，存刚从输入设备拿来的数据
   > - OutREG（Output register 输出寄存器）：8bit，保持将要输出到输出设备的数据

3. ISA（指令集体系结构 Instructure Set Architecture）  
   规定了计算机可以执行的每条指令极其格式，是**_计算机硬件和软件之间的接口_**，（MARIE 指令宽度是 16bit）  
   指令格式：**操作码（opcode） + 操作数地址（operand address）**， 在 MARIE 指令中是（4 + 12）bit

   | opcode | 指令     | 含义                                                    |
   | ------ | -------- | ------------------------------------------------------- |
   | 0001   | Load X   | 将地址为 X 的内存单元中的内容装入 AC                    |
   | 0010   | store X  | 将 AC 中的内容存储到地址为 X 的存储单元中               |
   | 0011   | Add X    | 将地址为 X 中的内容和 AC 中的内容相加，结果放到 AC 中   |
   | 0100   | Subt X   | 将 AC 中的内容减去地址 X 中的内容，然后将结果存入 AC 中 |
   | 0101   | Input X  | 从键盘输入一个数值到 AC 中                              |
   | 0110   | Output X | 将 AC 中的数值输出到显示器                              |
   | 0111   | Halt     | 终止程序的运行                                          |
   | 1000   | Skipcond | 条件跳转指令，有条件地跳过下一个指令                    |
   | 1001   | Jump X   | 无条件跳转指令，将 X 的值装入 PC 中                     |

4. 寄存器传输语言（RTL：register transfer language）  
   使用 M[X]表示存放在地址 X 存储单元中的数据，<-表示信息的传递  
   **因为和 AC 打交道的只有 MBR，所以要对 AC 中的数据进行操作不管是进去还是出来都要进过 MBR**

   - Load X

   ```
    //先将X（地址）放到MAR中
   MAR <- X

   //再用M[]的方式从MAR中拿到数据放到MBR中，再放到AC中
   MBR <- M[MAR], AC <-MBR
   ```

   - Store X

   ```
   MAR <- X , MBR <- AC
   M[MAR] <- MBR
   ```

   - Add X

   ```
   MAR <- X
   MBR <- M[MAR]
   AC <- AC + MBR
   ```

   - Subt X

   ```
   MAR <- X
   MBR <- M[MAR]
   AC <- AC - MBR
   ```

###### 4.3 指令的执行过程

1. 取指-译码-执行周期  
   计算机运行程序是所遵循的步骤： **_取指->译码->执行_**  
   取指：

   - 把 PC 中的内容复制到 MAR 中，然后从 M[MAR]中拿出内容，放到 IR
   - PC 要指向下一条指令，如果按 word 编址，就 PC+1，如果按 byte 编址，就加（word/byte）:2。

   译码：

   - 将 IR 的右边 12 位放入 MAR，此为操作数（或地址）
   - IR 的左边 4 位取出，此为操作码

   执行：

   - 如果需要，将 MAR 中的地址映射的数据取出
   - 执行指令

2. 中断和 IO  
   在 MARIE 模型中，使用**_中断控制的 IO_**来执行

   中断处理方法：

   1. 处理时间  
      在每次的**取指之前**要判断外部有没有中断请求，如果有就要先执行中断处理程序（ISR）
   2. 处理方法  
      使用**中断标志寄存器**来表示当时是否有中断，中断服务程序的入口地址要放在内存的中断向量表中  
      切换的时候找到 ISR 的入口地址之前要先保护原来 PC 的地址（context 上下文） ，使中断服务程序完成以后能回得来

###### 4.4 一个简单的程序

- 按照上述取指译码执行周期的规则，注意各种寄存器的变化

###### 4.5 汇编程序

1. 符号表  
   在汇编程序中，可以使用**标记符号（label）**来标识或命名一些特定的存储器地址，比如在示例程序中用来标记特殊地区的 XYZ 等变量，挺容易看懂的

2. 进制  
   DEC 表示十进制，HEX 表示十六进制

###### 4.6 MARIE 指令集的扩充

| opcode  | 指令    | 含义                                                                                                                      |
| ------- | ------- | ------------------------------------------------------------------------------------------------------------------------- |
| 0000(0) | Jns X   | 将 PC 内容存储到地址 X 处，然后跳转到地址 X+1,跳转+存储：比如执行子函数的操作，这样子函数的最上面一条指令存的就是返回地址 |
| 1010(A) | Clear   | AC 中的所有位清 0                                                                                                         |
| 1011(B) | AddI X  | 间接相加：进入地址 X 处，使用 X 单元的数值作为数据操作数的实际地址，取出操作数加到 AC 中                                  |
| 1100(C) | JumpI X | 间接跳转：进入地址 X 处，使用 X 单元的数值作为存储单元的实际地址，然后跳转至改存储单元                                    |

- Skipcond 条件跳转指令的简单判断  
  在 MARIE 中，地址是 12 位的，以**最高两位 & AC**来判断是否跳过一条指令。  
  跳过的条件：

  - IR[11-10] == 00 && AC < 0
  - IR[11-10] == 01 && AC == 0
  - IR[11-10] == 00 && AC > 0

  通常情况：

  > 000 && AC < 0  
  > 400 && AC == 0  
  > 800 && AC > 0

###### 4.7 译码方式

**硬连接（hardwired control）** 和 **微编程（microprogramming）**

##### Chapter 5 ISA 指令集体系结构

###### 5.2 指令格式 Instruction Formats

1. 大端和小端的位序问题

   - 端位（endian）：指的是计算机体系结构中的位序（byte order）
   - 小端（little endian）：**把最低位的字节放到低地址**（最低权重：最右边的位），如 PC 机  
     **高精度算术运算小端更快更容易**
   - 大端（big endian）：**把最高位的字节放到低地址**（最高权重，最左边的位），如 Unix 和 RISC 指令集  
     **计算机网络采用大端，因为位映射（bit mapping）的访问更有效**
   - 数据的低位和高位
     1. 低位->权重最低，最右边的
     2. 高位->权重最高，最左边的
   - 地址的低位和高位  
      地址编码越大就越高

2. CPU 内部存储机制

   - 栈体系结构（Stack Architecture）：使用栈来执行各种指令，**指令的操作数就隐含地存在栈的顶部**  
      注意逆波兰表达式（后缀表达式）**要考**
   - 累加器体系结构（Accumulator Architecture）：**将操作数隐含在累加器中**，如 MARIE
   - 通用寄存器体系结构（general purpose registor architecture）：比较常用，**（1）存储器-存储器、（2）寄存器-存储器、（3）装入-存储**

3. 逆波兰表示法（reverse polish notation 后缀表示法）

   - 中缀表示->后缀表示
     **操作数在前，操作符在后面**
   - 后缀表示->中缀表示
     借助栈，从左到右将字母依次入栈，如果遇到操作符就从栈中弹出两个操作数，进行操作数。

4. 扩展操作码（expanding opcode）  
   选用短操作码，而当有必要的时候有某种方法将操作码加长，因此地址的个数就要递减。**并不是所有指令都需要很多操作数，因此可以靠降低操作数地址数量来动态改变指令的数量**  
   详情见[CSDN](https://blog.csdn.net/qq_33745102/article/details/81413604)

###### 5.4 寻址（addressing）

1. 寻址方式  
   **寻址方式是指定指令中操作数的位置的方法**

2. 立即寻址（immediate addressing）  
   **是指在指令中操作码后面的数值就会直接被引用**，这个数叫做*立即数（immediate number）*

3. 直接寻址（direct addressing）  
   **是指在指令中直接指定要引用的数值的存储器地址**

4. 寄存器寻址（register addressing）  
   **被指定的寄存器中的内容将被作为指令的操作数**

5. 间接寻址（indirect addressing）  
   **地址域中的二进制数用来指定一个存储器的地址**，指令中（操作码+地址域）。地址域（存一个地址）->存储器（内含操作数）

6. 变址寻址（indexed addressing）
   **在指令后面存一个偏移量（offset），然后在某个寄存器中存在基地址（based address），这两个数加起来就是要访问的内存空间**

7. 栈寻址（stack addressing）
   操作数就放在栈中

###### 5.5 指令流水线（instruction-level pipline）

1. 定义  
   有的 cpu 会将**取指-译码-执行**分成一些较小的步骤，某些较小的步骤可以并行执行，这种时间上的交叠可以加快 cpu 的执行速度

2. 计算  
   假设 k 级流水线，tp 时钟周期，有 n 条指令。这种理想的情况要解决**取指令和取数据可以同时操作**

   - 完成时间：（k\*tp）+（n-1）tp = **（k+n-1）tp**
   - 加速比：理论上的加速比就是 k（流水线的级数）

3. 流水线冲突（pipline conflict）
   - 资源冲突（resource conflict）  
      比如对内存的访问：取指令和取操作数或者写回内存
   - 数据关联（data dependency）  
      一条指令要在另一条指令完成以后才能执行，一种常见就是后一条指令要使用前一条指令的结果作为操作数。  
      解决：插入一条不执行的 no-op 指令进去
   - 条件分支语句（conditional branching）

##### Chapter 6 存储器 Memory

###### 6.2 存储器的类型

1. RAM 和 ROM

   - RAM（Random Access Memory 随机存储器）：断电以后数据不存在：  
     速度：SRAM>DRAM

     - SRAM 静态随机存储器（D 触发器）：cache 高速缓存
     - DRAM 动态随机存储器（用电容来存储信息，每隔几毫米要 refresh 这时候不能读写数据）：main memory 主存、

   - ROM（Read-Only Memory 只读存储器）：断电以后数据还在,只能读不能写，比如开机程序存储在一个 ROM 里，**flash 闪存也是一种 ROM**

###### 6.3 存储器层次结构

1. 定义  
   **当今计算机采用不同类型的存储器组合配置，叫做存储器分层结构（hierarchical memory）**，呈金字塔型。  
   从顶端到低端，**访问速度和单位价格都逐渐降低，容量逐渐变大，越往后离 CPU 越远（其中 register 和 cache 集成在 CPU 上）**  
   **_寄存器 -> 高速缓存 -> 主存储器 -> 辅助存储器_**

2. 数据读写的访问方式  
   **CPU 会就近原则来寻找数据**，越远的地方访问时间越长，会发生如下事件：

   - **hit 命中**：CPU 请求的数据就在要访问的存储器中，简单讲就是**找到了！**
   - **miss 确实**：CPU 请求的数据不再要访问的存储器中，简单讲就是**没找到！**
   - **hit rate 命中率**：CPU 在某种特定存储器中请求到所需数据的百分比，**找到的比例**
   - **miss rate 缺失率**：= 1-hit rate
   - **hit time 命中时间**：**找到数据所需的时间**  
     **_通常情况下，处理一次缺失事件所花费的事件比处理一次命中所花费的时间要多_**

3. 原则
   - 时间局部性（Temporal Locality）：最近访问过的内容可能在不久的将来会被再次访问
   - 空间局部性（spatial Locality）：最近访问过的地方的周围很可能下一次会被访问（呈集中倾向）
   - 顺序局部性（sequential locality）：访问存储器的指令倾向于按顺序执行

###### 6.4 cache 高速缓存

1. 定义相关

   - **计算机系统会将那些需要频繁使用的数据复制到 cache 中，用于加快存储器的访问速度**
   - cache 由 SRAM 构成

2. 映射模式

   - 指的是**数据最初被复制到 cache 中时存放的位置**
   - **域：将地址的二进制分为不同的组，代表不同的意义，根据映射模式的不同，可以有两到三种分组（两到三个域）**
   - **block 块：主存和 cache 的存储空间会被分成相同大小的块， 一个 block 包含很多的字 word**
   - word field 字域：某个 word 在特定 block 中的位置（offset 偏移量）
   - Tag field 标签域：对一个 cache 或主存块 block 的唯一标记
   - **valid bit 有效位：标记该 cache block 是否是一个有效数据**
   - dirty bit 脏位：用于标记该数据是否被修改过，需要被写回内存

3. 直接映射（Direct mapping）  
   **每一个主存的块在只能映射到唯一一个特定的 cache 块中，映射为取模操作**

   - **映射图示**
     ![pic6.1](https://pic.downk.cc/item/5fabe9e71cd1bbb86b0b5eba.jpg)  
      图中我们知道主存中第 0 块和第 10 块都会映射在 cache 的第 0 个 block，区别它们的方法就是用 Tag 域

   - 主存地址域划分  
     ![pic6.2](https://pic.downk.cc/item/5fabeac41cd1bbb86b0b8ee4.jpg)  
     计算方法：

     1. 先计算主存地址的全部位（All）：按 word 寻址，将主存地址写成 2^n 形式，n 就是主存的地址长度
     2. word 域：每个 block 含有多少个 word，写成 2^n 形式，n 就是 word 域的长度
     3. block 块域：cache 有几个块，写成 2^n 形式，n 就是 block 域的长度
     4. Tag 域：用总的域剪掉 word 和 block 两个域就是 Tag 域的长度

   - 读数据时
     1. 解析地址，取出 block 域，寻找 cache 中对应的 block
     2. 检查该 cache 的 valid 是否为 1（数据是否有效）
     3. 检查地址中的 Tag 域的内容和对应 cache Tag 是否相等
     4. 相等则命中 hit，在 word 域的偏移量中取数据。反之则缺失 miss，到主存中取数据
     5. 在主存中取到数据以后会放到 cache 里

4. 全关联高速缓存（Fully Associative Cache）  
   **cache 的每一个块都可以存储来自内存各部分的块，因此主存地址只用保存 Tag 域和 word 域**

   - 主存地址域划分  
     ![pic6.3](https://pic.downk.cc/item/5facbe861cd1bbb86b3f20f8.jpg)  
     计算方法和上面相同

   - 读数据时  
     会在所有有效 valid 的内存块中寻找是否具有相同 Tag 的 block。  
     **缺点很明显：就是每一次都要检查所有的有效 cache，降低命中时间**

   - cache 装满以后  
     如果这时候还有新的一个 block 被复制过来，那么就要用**置换策略**来决定哪一个块要被丢弃（victim block 牺牲块）

5. **N 路组关联高速缓存（Set Associative Cache）**

   - 方式
     结合了直接映射和全关联映射的优点，**每个组域相同的主存块会被放到 cache 中的某一组中，因此在读数据时只用找改组中是否存在目标数据**（而不用搜索全部 cache 块）

   - 主存地址域划分  
     ![pic6.4](https://pic.downk.cc/item/5facc0771cd1bbb86b3fa2f8.jpg)  
     计算方法：
     - set 域：拥有 M 个 block 的 cache 采用 N-way 组关联映射，那么 set 域的长度就是 log2（M/N）。**M/N 就是有多少组**

6. 置换策略  
    FIFO（先进先出）和 LRU（最近最少被使用）  
   在操作系统中会详细讲

7. 命中时间和命中率  
   ![pic6.5](https://pic.downk.cc/item/5facc1f61cd1bbb86b4008c1.jpg)

8. 写策略（write policy）  
   对于脏块（被修改过的块）的处理方法
   - **写通（write-though）**：在每次写操作时 CPU 会同时更新 cache 和 Main Memory 的对应数据块。  
     缺点是慢，优点是高速缓存的数据块始终和主存保持一致
   - **写回（write-back）**：在某个脏块要被丢弃的时候，才会写回主存  
      优点是块，缺点是在某一时刻 cache 和 main memory 的数据块回不一致

###### 6.5 虚拟内存

在操作系统中会详细讲
